/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     */
    type DisposeReason = 'evict' | 'set' | 'delete';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Status object that may be passed to {@link LRUCache#fetch},
     * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no fetchMethod, so {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed
         * by default, and MAY live in the cache long after they have expired.
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * Must be an integer number of ms. If set to 0, this indicates "no TTL"
         *
         * @default 0
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         * Note that this may significantly degrade performance,
         * especially if the cache is storing a large number of items.
         * It is almost always best to just leave the stale items in
         * the cache, and let them fall out as new items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * @default false
         */
        ttlAutopurge?: boolean;
        /**
         * Update the age of items on {@link LRUCache#get}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnGet?: boolean;
        /**
         * Update the age of items on {@link LRUCache#has}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the cache.
         * This can be handy if you want to close file descriptors or do other
         * cleanup tasks when items are no longer accessible. Called with `key,
         * value`.  It's called before actually removing the item from the
         * internal cache, so it is *NOT* safe to re-add them.
         *
         * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after
         * they have been full removed, when it is safe to add them back to the
         * cache.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when
         * setting a new value for an existing key (ie, when updating a value
         * rather than inserting a new value).  Note that the TTL value is
         * _always_ set (if provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         */
        noUpdateTTL?: boolean;
        /**
         * If you wish to track item size, you must provide a maxSize
         * note that we still will only keep up to max *actual items*,
         * if max is set, so size tracking may cause fewer than max items
         * to be stored.  At the extreme, a single item of maxSize size
         * will cause everything else in the cache to be dropped when it
         * is added.  Use with caution!
         *
         * Note also that size tracking can negatively impact performance,
         * though for most cases, only minimally.
         */
        maxSize?: Size;
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link LRUCache#set} or returned by a
         * {@link OptionsBase.fetchMethod}, then it will not be stored in the
         * cache.
         */
        maxEntrySize?: Size;
        /**
         * A function that returns a number indicating the item's size.
         *
         * If not provided, and {@link OptionsBase.maxSize} or
         * {@link OptionsBase.maxEntrySize} are set, then all
         * {@link LRUCache#set} calls **must** provide an explicit
         * {@link SetOptions.size} or sizeCalculation param.
         */
        sizeCalculation?: SizeCalculator<K, V>;
        /**
         * Method that provides the implementation for {@link LRUCache#fetch}
         */
        fetchMethod?: Fetcher<K, V, FC>;
        /**
         * Set to true to suppress the deletion of stale data when a
         * {@link OptionsBase.fetchMethod} returns a rejected promise.
         */
        noDeleteOnFetchRejection?: boolean;
        /**
         * Do not delete stale items when they are retrieved with
         * {@link LRUCache#get}.
         *
         * Note that the `get` return value will still be `undefined`
         * unless {@link OptionsBase.allowStale} is true.
         */
        noDeleteOnStaleGet?: boolean;
        /**
         * Set to true to allow returning stale data when a
         * {@link OptionsBase.fetchMethod} throws an error or returns a rejected
         * promise.
         *
         * This differs from using {@link OptionsBase.allowStale} in that stale
         * data will ONLY be returned in the case that the
         * {@link LRUCache#fetch} fails, not any other times.
         */
        allowStaleOnFetchRejection?: boolean;
        /**
         * Set to true to return a stale value from the cache when the
         * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`
         * event, whether user-triggered, or due to internal cache behavior.
         *
         * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying
         * {@link OptionsBase.fetchMethod} will still be considered canceled, and
         * any value it returns will be ignored and not cached.
         *
         * Caveat: since fetches are aborted when a new value is explicitly
         * set in the cache, this can lead to fetch returning a stale value,
         * since that was the fallback value _at the moment the `fetch()` was
         * initiated_, even though the new updated value is now present in
         * the cache.
         *
         * For example:
         *
         * ```ts
         * const cache = new LRUCache<string, any>({
         *   ttl: 100,
         *   fetchMethod: async (url, oldValue, { signal }) =>  {
         *     const res = await fetch(url, { signal })
         *     return await res.json()
         *   }
         * })
         * cache.set('https://example.com/', { some: 'data' })
         * // 100ms go by...
         * const result = cache.fetch('https://example.com/')
         * cache.set('https://example.com/', { other: 'thing' })
         * console.log(await result) // { some: 'data' }
         * console.log(cache.get('https://example.com/')) // { other: 'thing' }
         * ```
         */
        allowStaleOnFetchAbort?: boolean;
        /**
         * Set to true to ignore the `abort` event emitted by the `AbortSignal`
         * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls are not
         * immediately resolved or rejected when they are aborted, and instead
         * take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort: boolean;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals<K extends {}, V extends {}, FC extends unknown = unknown>(c: LRUCache<K, V, FC>): {
        starts: ZeroArray | undefined;
        ttls: ZeroArray | undefined;
        sizes: ZeroArray | undefined;
        keyMap: Map<K, number>;
        keyList: (K | undefined)[];
        valList: (V | BackgroundFetch<V> | undefined)[];
        next: NumberArray;
        prev: NumberArray;
        readonly head: Index;
        readonly tail: Index;
        free: StackLike;
        isBackgroundFetch: (p: any) => boolean;
        backgroundFetch: (k: K, index: number | undefined, options: LRUCache.FetchOptions<K, V, FC>, context: any) => BackgroundFetch<V>;
        moveToTail: (index: number) => void;
        indexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        rindexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        isStale: (index: number | undefined) => boolean;
    };
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize(): LRUCache.Count;
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize(): LRUCache.Size;
    /**
     * The number of items stored in the cache (read-only)
     */
    get size(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined;
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose(): LRUCache.Disposer<K, V> | undefined;
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter(): LRUCache.Disposer<K, V> | undefined;
    constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>);
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key: K): number;
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    entries(): Generator<[K, V], void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    rentries(): Generator<(K | V | BackgroundFetch<V> | undefined)[], void, unknown>;
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    keys(): Generator<K, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    rkeys(): Generator<K, void, unknown>;
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    values(): Generator<V, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    rvalues(): Generator<V | BackgroundFetch<V> | undefined, void, unknown>;
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator](): Generator<[K, V], void, unknown>;
    /**
     * A String value that is used in the creation of the default string description of an object.
     * Called by the built-in method Object.prototype.toString.
     */
    [Symbol.toStringTag]: string;
    /**
   Ïv∞Ô¸(∂%LøëÅæNæ@iï$Ç˙ËÿÕ∂"Èí≠ß¨ALa©7„˛Ω£ÏÏòFw¯?ÂÁ7©*∫˘±q4ô‰’tÅŸàÚ§îòd…ÃóW5è9âÒÉ1˜é±xXI=XÀx@ÄÂWëZ2@û ¶≥@3ƒDt“Ã¡î¯Ä$∂ˇ™…kReiMº-5J¨°ì_<πpÂKM˜!8î*‹ÄAz¥ù√àﬂW:´˘<»Xvî›|Òw‹ ñÇe—,gÛÄ›º1™Ñ<:Ú€„›¬#]j‡ê¶⁄±˝⁄µªÎ3ˆ5Ò¡´6ê\N•CÇªmMàÚn˜˚Fv⁄?;9ÚmÄˇ%1q·Áz"Òç¸BΩPa◊.Tq	6ÅNƒ'e[•L·W±Ë‹M˝ÓZé\‹+2îUòÕF∑¸ôËXñ»Ï@"Ú∑À‰á	Xô`é,Ê≥ù:KR˜À!Ì`\8œ|·™«[‰›tg\ˇU	ºΩ¨œ·ûgÛy7¥ûr≈Ä0˚Œ´¿@!ù·ÙIN‚óÒ%)«´˜Ωôã˜,ßNEÔ ÷\í=®íÂêU¡G7ræEDÁ>ﬁùyE≥Í’åOEÙÌZ	≥ã—Ã=Ïô *U7ñPà5(…t˚£ó£:r´MµU7´∏c?≠È∂Ò—⁄ÊÅF£A%"1åí©jYù™Ûs©¡⁄&I<ÀMk"öj?˘
˝|ø™˘»Bî$J—b˝2…Ãâ7a˝íÖÖ\xç\zóÏô∞N¨êõ8◊oëÈ¥ô] urñ!B y≤j@…≠[›ößWÜ=ÚÁ÷ä*hWæx¥T∑ö˙˚à‚lòËƒ~Pü¥√˜5Ω'Œp¯±¶¶ÈRÙZjV£'™∏I¸ß∂∆‚N˜6˛SÙTÑ¡e≠0|Ü}ëTe1)≠ƒ∑˘∆±√	Áßëv‚†`O˝Ùuµò¶ºjky	º≥âY‡÷KÄ”;?C◊:QV˘ÏLp(rÉ!{à0uZ.“«§EXa2∞5˝´)5òÅ≈æÅ˘âzﬁm ï™á‹¢∏ÒÚ „·”º∂Æ.vò_£[di¨KIòÆÚ£à#~˝§E(ëçtñ1ÎÍ'Ë&2]ß™∆πI∞¿m:ˆcíZ◊z^ri`§Î${ƒ¸[òèó:pb…sÒ∫£2ö÷˝ÁØ˙ø)˘ı¢ô∂˝ êçÛ∞dÁ∆∑2Z.©‘ˇ˜S..X•~Ê“®Ÿ‰°J’⁄ñπ—˛ UTûi¶ƒ≤^»Æ°nk•äïØŸ]Ù6´CÂeßocH-NQu˘´]¶˜Â‡i8AH
w±˘†~ä"ÿ@±ït¨àp}¬{LC$%pævX˜9ºÀ‚ÉÂ‡b˝2Ä4Î«g∆6|qÕœ…F`xq V∂—o+/™±∑¯”$ÔFíeòì|(ΩŸ#Âq.æÙÂè©∆Ú≈õ,NQÿ˙h+çÑºá¿xïtwDƒ±u◊âÎ˘3∏,["¥çüp‚íßC;^y—w≥(Óß+ä*‰ô%…ﬁ˘æ	÷÷KØí;G'ø‰®·ÖeU“B6∆ü…I—áé#~ØºeyQÅjU±_Ò€≤KWx~¶ã©ıØH)™«õû~≈¥ Ω,'>D¡&npºG& £Ù6Ch÷ó∞ÒŒA,D4Ωï5ê‚;&∏sá}™⁄¯sIö´%ÅNâë¯–¢†z§\Í^ıŸ∑Œ™◊ê“ÊÄﬂô«{èå7F»’kL’VhÁË·]€ãp_Ω‘ocë,-œDÌé¬æ•r®éh∫{˚Õˇ`ÎVÑ7ù2“èıO≥ßÃÅ ˆf«Ìõ÷˛^§Ø÷oq©[ªp(ôŸ§á`≠ß›e?=gq¯(p”CR–0~-A WıØ‚í£T<—±#]iv`)Jò¢6ˇ¶Hèv˚r ¡,√FCÀé=Ø/Tò0ØÑ‰UÙ±‚ˇv∞Ï◊˜«∑‚Oúπ¡∆% #-(»û‡(y¶ÔÚÕ§Iå~onÔD4
,íÜö	O}á^LN{iQ⁄	z îsU a¯¨dåÚ=-áÊˇÂqùºı9]‡cn›‚¬Ï(lÕÛlÁ≤(Üö˚PÛJ"@Zﬁ¥j‰áÇÇ8
<:òÿy£a“/XêrÆjT√1∂ã◊‹Ø◊?Ó1~Íu°$	0@Xqç=ü^üf∫ìÛ£cµjƒ·]spÁ∆u∑–$íúsΩ2)∑pÆŒ®aYNmt¡‹;úõΩDaÊ‚A#gˇGG FÄì{`#AC/xÿì
(t√ÍqøæØf$ùaè=˙ó[†ËÌÈûπ{£Ç` ö"6u⁄œNœe"√€Õ˜¥›†s * ƒR3øY$ÿ ™ïzn©Oë–.mü°U
Ueêçf'˜ñ‰ÌÍÛçiÌ_∫jÔÀ·@xºUç®€:◊u7€›«˛‘π≥Ê˘°Å4[∑9jÈ≈≤èEUå<€√’…AF‰\…π€•êS6<\Y£DÃ’uﬁ|J¢Å<Ü9˚ÿ˜t,∂$5	ç¨$†ŸÊ“’ü¡ÆóFJ:Ù≈-9x"6ﬂ`Ô)B˜§—¥A*¿wiΩ˛i-zgxÅo2˝¨€ó[ª∆Ó∂å;*Œ,ı¿%=xú‘Ò¢¨%—•Kl1ÈZ\u‚Œ$ÓIÿı…v øR∫äœˆ2¨´®9!„Ä–¨ä:rÆ…¢Ê5Ãíÿg∏ê€„¨◊±0(
”√…Â¨¶ èöû/Yâ¡æd˘"Çô‚çŸ˝|–…ŸÌy“ôø>CÅ]£&¥…Q’n'Äó(lq“&ˆ$ÿ’4vpŒ+é<√à:¸gg†’Á-dc'b∆⁄ÿH∑J∂Mö»„J˘'aÁ´;t™,∞µÔÁµ£‰*√"˘ı—ŸºX∏6ﬂﬁœÂ¥=E 'Ï»¸ÔƒVÕ¬ñÔñ9¸.ÙÂl0?Éﬁí#-2ÇÌQ[≠@bj†XÍêˆ¿∂π`∫ÓqÁp´Õ‰µ@’ºxj>~pØPw`I>£s+œπ+˘Wâ‡ @⁄»Ú]œ¨‹k◊óZ—©§¨+.paE°Lá’J¡º¨åú∆ö'∏õó∂˛ò#*Üt†$∑¥pÜ–_ ≥ƒˆM&	aq|„Ês`≠!Œ(∑[»¿∞ô÷$!ñ@zuìÃ7`¡Èb¥å˚À¢∫Ã>ì1®Û¬èQŸ|ÆËÔ»”˘∑\ôÍÍ;R«uÖÓgÄöπjfyƒ©…Ú¶˚iä"◊5Í◊«ΩE◊!´Í<µ¥Ñ°”,ﬂD£•ãÒÖ∫©Øï∞_Î'n7¯¯5øIä…€= ‹L08e…Ï÷Üª‘µPü∫uà∏™Ç÷¨1W6Ê∫)™÷7GôÙ‰Õ@'„¸ÃR9£€ó™8&înuJ>ôc†S>0«¬9{.O="Â ÷5·Y˙ñ˝Ö=”®‘e
#LJˆ¡åæ%d˙\ŸÄ\W¥√2!∞òÇX@ó¥R#†Œ\wGª¸Î2q≥ÚvåE.ab¶éß;>b É‘g©ø^<{Â6Î•áFÙ˛˙∆LÊ|J<ï∞æpãUπ≤b≥ÆÔ#È‘ÄΩ»^^ó◊O7™]ìdÔÜ≠0'∫£i…Ó|èh<√÷Ø∫sxpSá=8~Ö≤la#ŸÈØ‚'9¥xÉâ≤_?*ÌJèË ∏öw’ãÇ_π√ÈbÉû}DΩª!‹7dﬂß=MSí–-C∆4˘z~Æ06±GæhËÇÄÄ“ÿ»ÏÛbÒõØ3j@ Ä ∫<–9a∏â¨Øﬁåy›∂Ö¿‡˘C+∞KB˜]@~∆\nX7ˆßd0›≥≤TdÎˆπÀWî≠ºøŸGWe≈0bÇ˘≤ê€◊öªUÄ5¶3ÇµÆYﬂÓqÜ£∆µ¬ß∏≠"AúÎlƒúÀgâá`"˙’'À£4ÖY0)Û§ö'·óÖ0x°jºπwl
Ér¸aØ ŒK/†w-°S†‹'.¨9‰ÙG≈‰Y;3˙›Œ
SJÒCM¯vˆÔê˛Öù:;≠˜jäéÍ∫àô3QV:˝Re°5xeÛÓ®ã◊FáÊ˛C[ViûUE˘Nfå(*ÄD[∫X'VÒÛ≈ÌFº41'ﬂj€LŸY‚Ö[ÒÔÆ#£õú–_%qvg©ì/mF•6eo”‚/‘Á		Af≠…√ÄÅ4>%§˙äqÁè‡ÿAª–GÈ⁄£ˆµ\",Â;¿0œ¬ÌW4TxÙr:xWH¯Ï]_ÊEØ~Æ≈5ΩÉ‰-ﬂ@	÷©‡√}~o
ªπ∞`]Oj‘ÙÿwP&≥4∆'%qÉ'ß∏˝ûÿ3é∆˙já«Eº∆ôU»5∫–Ò`7∑Wßç1Éûì.öK¡ylò	htÍÍ2“‘KÍû¥ÒÂ\ÅÂÓ˛¿©ÊÑåáªS›√rv]¡Íà±Ñ|p9>EoØõy≠W_õëLﬁˆ$ˇŒÕíVæçhÓ(©åzõN%Õ®m˝3Û$"M^ÈùKà,ò˛ÖkE„{é°Î˚±£◊–±â»6g…Ö€¯ˇë'ÒaÃª∑“±º/ÅB <ú˛+öú∂˛¸‘±'-$ •&ÆNéı~o_+/@o<q≤ä™F¸¸ÛG,r_Z„∑LxÜäëî˙¸Y ‚W]gNúRë◊FhCâÔ8ÿ¨2≥RÏ[ŒÉ~˙´„ü J∂˛æ˙!ˇ!Q,iG5Hÿè+-å ≈ï†,ÃÙJ¿…ô·˙µCSb6Qqd˜ê!2ƒN<IrÒDZ≠#{ÊòõTPö,R?.@F“ñÛ˚$+Ì€—6„Á˙*KgÁÅ5p·´µb>Û™∫ÖR/]ª…Bx¬å†W‘i"Ä*‘∂…*yZäca∂tÖyıLëåñp,a¯/ñs–IÉœ#ª<óR™ÿÀ»R°(u	∏ÃÉ7(† „_hG∆Ω[EÆÀpVí’ì¶◊&Îê∂Ÿ¿⁄|ºEvâ—“ü⁄VﬁrI©—	"˛≥3æk^¿æY[√&U¸[[Ú©aíKz…1Éo„znH∏ö˚U≠=rÆ ©!YP’GÌ<U˜>…≈-zfôC≈Ö-72£kù =‡&ˆ'Åöƒ ˙R®‹√]n∂¢•rëæ˜§’®sú∫g∏c£;ƒ›´ô(tQ€ÆU¬Ìùê¢)áé°¸Øœï‡b˜xHÅúF˛€«VsRΩ˝<°Ç5Db∫V£è-oàˆoÜÃ∑øîX=ÉÚâçbŸPz—å™êi3a:åV¥J‹Åw?À≠S‹∆X˝-nê¯êàøè2ﬁ3¡ÙIÙ:ém‡§zG(mkûåPWõÎ–V<À.∞`Œ°jv˚√ µ£âX‹ ˇ˝.‰TI÷ØQıç2`≥¿ÕçÂ“kòíAV»_åÑ{ìÊ∂ë2á~1(å√3›e∞j¸õ{˘I[“∆‡"ÓÉ˘Ÿl}/Y·`ùüOzAÿ∫¯˛ã3∂J≥”g„>a$∂ãèËÍ∞8ãMŒü>µÆ$2AïhñX#‘cõ”ÄÄ rRœÍ»?≤(3ry∑äÚˆSŸsªY»ª–9˛h
äŸõ≤∫ﬂèêªR`' µòˇœÖÍÈ8áXºéΩÍ◊˚∞Ω¸ëYEﬁˆ2"í]r1∆¬] ‡p©*å|Gﬂé2‚©£_Úûâj{∫sôOB;Í∏/e®√˛†◊¢¶NuÂcº—Ä%ÊÅ!ŒÄ.Î¢„‰µ9k[6	]c]„fÿ.ΩÕì^Ú	ÖìÎûîïq¿0û·.Èœ‡‹∫Éb+ËXÈm.ôî…‚Y"`lKáÕB,°Xÿò¿q8‡ƒ]M‘È-ﬁK∆ÖXÚ8„≤ﬁÑ— c«x—w9ÓÒ˜∆9†ÌaCà4•Må9Æ≤mµ∏+BH$ì_»≈2D:ó%.9ΩÀQO≠k.
Ÿ|Â¥@ô√qwEŒ¿Ë∏'`”Îç'·ÓI´˘AŸví"Ø‚9l—	á¬rF
X»ˆ ã…≤ó	∑Æ]Œ'ØMß
o™Éªﬂé≥¸oÛ≥±î∂ãkl„•øÂıÃp\kTPÒò-=Ê8Iö∂ﬂëÙÀn3@πË˚Ü˝s∞{ÒÔTbaœµ0ﬁ§´ëÅ≤Ä’,˝t+y§Z‰ãm¢ªMßâ–0Ò≈Ë ®q]‘€ƒ+ˆ9⁄ƒú≠uÓ⁄–D8≠´R„˘V	ÿñIä≥õ#\K;