# lru-cache

A cache object that deletes the least-recently-used items.

Specify a max number of the most recently used items that you
want to keep, and this cache will keep that many of the most
recently accessed items.

This is not primarily a TTL cache, and does not make strong TTL
guarantees. There is no preemptive pruning of expired items by
default, but you _may_ set a TTL on the cache or on a single
`set`. If you do so, it will treat expired items as missing, and
delete them when fetched. If you are more interested in TTL
caching than LRU caching, check out
[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).

As of version 7, this is one of the most performant LRU
implementations available in JavaScript, and supports a wide
diversity of use cases. However, note that using some of the
features will necessarily impact performance, by causing the
cache to have to do more work. See the "Performance" section
below.

## Installation

```bash
npm install lru-cache --save
```

## Usage

```js
// hybrid module, either works
import { LRUCache } from 'lru-cache'
// or:
const { LRUCache } = require('lru-cache')
// or in minified form for web browsers:
import { LRUCache } from 'http://unpkg.com/lru-cache@9/dist/mjs/index.min.mjs'

// At least one of 'max', 'ttl', or 'maxSize' is required, to prevent
// unsafe unbounded storage.
//
// In most cases, it's best to specify a max for performance, so all
// the required memory allocation is done up-front.
//
// All the other options are optional, see the sections below for
// documentation on what each one does.  Most of them can be
// overridden for specific items in get()/set()
const options = {
  max: 500,

  // for use with tracking overall storage size
  maxSize: 5000,
  sizeCalculation: (value, key) => {
    return 1
  },

  // for use when you need to clean up something when objects
  // are evicted from the cache
  dispose: (value, key) => {
    freeFromMemoryOrWhatever(value)
  },

  // how long to live in ms
  ttl: 1000 * 60 * 5,

  // return stale items before removing from cache?
  allowStale: false,

  updateAgeOnGet: false,
  updateAgeOnHas: false,

  // async method to use for cache.fetch(), for
  // stale-while-revalidate type of behavior
  fetchMethod: async (
    key,
    staleValue,
    { options, signal, context }
  ) => {},
}

const cache = new LRUCache(options)

cache.set('key', 'value')
cache.get('key') // "value"

// non-string keys ARE fully supported
// but note that it must be THE SAME object, not
// just a JSON-equivalent object.
var someObject = { a: 1 }
cache.set(someObject, 'a value')
// Object keys are not toString()-ed
cache.set('[object Object]', 'a different value')
assert.equal(cache.get(someObject), 'a value')
// A similar object with same keys/values won't work,
// because it's a different object identity
assert.equal(cache.get({ a: 1 }), undefined)

cache.clear() // empty the cache
```

If you put more stuff in the cache, then less recently used items
will fall out. That's what an LRU cache is.

## `class LRUCache<K, V, FC = unknown>(options)`

Create a new `LRUCache` object.

When using TypeScript, set the `K` and `V` types to the `key` and
`value` types, respectively.

The `FC` ("fetch context") generic type defaults to `unknown`.
If set to a value other than `void` or `undefined`, then any
calls to `cache.fetch()` _must_ provide a `context` option
matching the `FC` type. If `FC` is set to `void` or `undefined`,
then `cache.fetch()` _must not_ provide a `context` option. See
the documentation on `async fetch()` below.

## Options

All options are available on the LRUCache instance, making it
safe to pass an LRUCache instance as the options argument to make
another empty cache of the same type.

Some options are marked read-only because changing them after
instantiation is not safe. Changing any of the other options
will of course only have an effect on subsequent method calls.

### `max` (read only)

The maximum number of items that remain in the cache (assuming no
TTL pruning or explicit deletions). Note that fewer items may be
stored if size calculation is used, and `maxSize` is exceeded.
This must be a positive finite intger.

At least one of `max`, `maxSize`, or `TTL` is required. This
must be a positive integer if set.

**It is strongly recommended to set a `max` to prevent unbounded
growth of the cache.** See "Storage Bounds Safety" below.

### `maxSize` (read only)

Set to a positive integer to track the sizes of items added to
the cache, and automatically evict items in order to stay below
this size. Note that this may result in fewer than `max` items
being stored.

Attempting to add an item to the cache whose calculated size is
greater that this amount will be a no-op. The item will not be
cached, and no other items will be evicted.

Optional, must be a positive integer if provided.

Sets `maxEntrySize` to the same value, unless a different value
is provided for `maxEntrySize`.

At least one of `max`, `maxSize`, or `TTL` is required. This
must be a positive integer if set.

Even if size tracking is enabled, **it is strongly recommended to
set a `max` to prevent unbounded growth of the cache.** See
"Storage Bounds Safety" below.

### `maxEntrySize`

Set to a positive integer to track the sizes of items added to
the cache, and prevent caching any item over a given size.
Attempting to add an item whose calculated size is greater than
this amount will be a no-op. The item will not be cached, and no
other items will be evicted.

Optional, must be a positive integer if provided. Defaults to
the value of `maxSize` if provided.

### `sizeCalculation`

Function used to calculate the size of stored items. If you're
storing strings or buffers, then you probably want to do
something like `n => n.length`. The item is passed as the first
argument, and the key is passed as the second argument.

This may be overridden by passing an options object to
`cache.set()`.

Requires `maxSize` to be set.

If the `size` (or return value of `sizeCalculation`) for a given
entry is greater than `maxEntrySize`, then the item will not be
added to the cache.

### `fetchMethod` (read only)

Function that is used to make background asynchronous fetches.
Called with `fetchMethod(key, staleValue, { signal, options,
context })`. May return a Promise.

If `fetchMethod` is not provided, then `cache.fetch(key)` is
equivalent to `Promise.resolve(cache.get(key))`.

If at any time, `signal.aborted` is set to `true`, or if the
`signal.onabort` method is called, or if it emits an `'abort'`
event which you can listen to with `addEventListener`, then that
means that the fetch should be abandoned. This may be passed
along to async functions aware of AbortController/AbortSignal
behavior.

The `fetchMethod` should **only** return `undefined` or a Promise
resolving to `undefined` if the AbortController signaled an
`abort` event. In all other cases, it should return or resolve
to a value suitable for adding to the cache.

The `options` object is a union of the options that may be
provided to `set()` and `get()`. If they are modified, then that
will result in modifying the settings to `cache.set()` when the
value is resolved, and in the case of `noDeleteOnFetchRejection`
and `allowStaleOnFetchRejection`, the handling of `fetchMethod`
failures.

For example, a DNS cache may update the TTL based on the value
returned from a remote DNS server by changing `options.ttl` in
the `fetchMethod`.

### `noDeleteOnFetchRejection`

If a `fetchMethod` throws an error or returns a rejected promise,
then by default, any existing stale value will be removed from
the cache.

If `noDeleteOnFetchRejection` is set to `true`, then this
behavior is suppressed, and the stale value remains in the cache
in the case of a rejected `fetchMethod`.

This is important in cases where a `fetchMethod` is _only_ called
as a background update while the stale value is returned, when
`allowStale` is used.

This is implicitly in effect when `allowStaleOnFetchRejection` is
set.

This may be set in calls to `fetch()`, or defaulted on the
constructor, or overridden by modifying the options object in the
`fetchMethod`.

### `allowStaleOnFetchRejection`

Set to true to return a stale value from the cache when a
`fetchMethod` throws an error or returns a rejected Promise.

If a `fetchMethod` fails, and there is no stale value available,
the `fetch()` will resolve to `undefined`. Ie, all `fetchMethod`
errors are suppressed.

Implies `noDeleteOnFetchRejection`.

This may be set in calls to `fetch()`, or defaulted on the
constructor, or overridden by modifying the options object in the
`fetchMethod`.

### `allowStaleOnFetchAbort`

Set to true to return a stale value from the cache when the
`AbortSignal` passed to the `fetchMethod` dispatches an `'abort'`
event, whether user-triggered, or due to internal cache behavior.

Unless `ignoreFetchAbort` is also set, the underlying
`fetchMethod` will still be considered canceled, and any value
it returns will be ignored and not cached.

Caveat: since fetches are aborted when a new value is explicitly
set in the cache, this can lead to fetch returning a stale value,
since that was the fallback value _at the moment the `fetch()` was
initiated_, even though the new updated value is now present in
the cache.

For example:

```ts
const cache = new LRUCache<string, any>({
  ttl: 100,
  fetchMethod: async (url, oldValue, { signal }) => {
    const res = await fetch(url, { signal })
    return await res.json()
  },
})
cache.set('https://example.com/', { some: 'data' })
// 100ms go by...
const result = cache.fetch('https://example.com/')
cache.set('https://example.com/', { other: 'thing' })
console.log(await result) // { some: 'data' }
console.log(cache.get('https://example.com/')) // { other: 'thing' }
```

### `ignoreFetchAbort`

Set to true to ignore the `abort` event emitted by the
`AbortSignal` object passed to `fetchMethod`, and still cache the
resulting resolution value, as long as it is not `undefined`.

When used on its own, this means aborted `fetch()` calls are not
immediately resolved or rejected when they are aborted, and
instead take the full time to await.

When used with `allowStaleOnFetchAbort`, aborted `fetch()` calls
will resolve immediately to their stale cached value or
`undefined`, and will continue to process and eventually update
the cache when they resolve, as long as the resulting value is
not `undefined`, thus supporting a "return stale on timeout while
refreshing" mechanism by passing `AbortSignal.timeout(n)` as the
signal.

For example:

```js
const c = new LRUCache({
  ttl: 100,
  ignoreFetchAbort: true,
  allowStaleOnFetchAbort: true,
  fetchMethod: async (key, oldValue, { signal }) => {
    // note: do NOT pass the signal to fetch()!
    // let's say this fetch can take a long time.
    const res = await fetch(`https://slow-backend-server/${key}`)
    return await res.json()
  },
})

// this will return the stale value after 100ms, while still
// updating in the background for next time.
const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })
```

**Note**: regardless of this setting, an `abort` event _is still
emitted on the `AbortSignal` object_, so may result in invalid
results when passed to other underlying APIs that use
AbortSignals.

This may be overridden on the `fetch()` call or in the
`fetchMethod` itself.

### `dispose` (read only)

Function that is called on items when they are dropped from the
cache, as `this.dispose(value, key, reason)`.

This can be handy if you want to close file descriptors or do
other cleanup tasks when items are no longer stored in the cache.

**NOTE**: It is called _before_ the item has been fully removed
from the cache, so if you want to put it right back in, you need
to wait until the next tick. If you try to add it back in during
the `dispose()` function call, it will break things in subtle and
weird ways.

Unlike several other options, this may _not_ be overridden by
passing an option to `set()`, for performance reasons.

The `reason` will be one of the following strings, corresponding
to the reason for the item's deletion:

- `evict` Item was evicted to make space for a new addition
- `set` Item was overwritten by a new value
- `delete` Item was removed by explicit `cache.delete(key)` or by
  calling `cache.clear()`, which deletes everything.

The `dispose()` method is _not_ called for canceled calls to
`fetchMethod()`. If you wish to handle evictions, overwrites,
and deletes of in-flight asynchronous fetches, you must use the
`AbortSignal` provided.

Optional, must be a function.

### `disposeAfter` (read only)

The same as `dispose`, but called _after_ the entry is completely
removed and the cache is once again in a clean state.

It is safe to add an item right back into the cache at this
point. However, note that it is _very_ easy to inadvertently
create infinite recursion in this way.

The `disposeAfter()` method is _not_ called for canceled calls to
`fetchMethod()`. If you wish to handle evictions, overwrites,
and deletes of in-flight asynchronous fetches, you must use the
`AbortSignal` provided.

### `noDisposeOnSet`

Set to `true` to suppress calling the `dispose()` function if the
entry key is still accessible within the cache.

This may be overridden by passing an options object to
`cache.set()`.

Boolean, default `false`. Only relevant if `dispose` or
`disposeAfter` options are set.

### `ttl`

Max time to live for items before they are considered stale.
Note that stale items are NOT preemptively removed by default,
and MAY live in the cache, contributing to its LRU max, long
after they have expired.

Also, as this cache is optimized for LRU/MRU operations, some of
the staleness/TTL checks will reduce performance.

This is not primarily a TTL cache, and does not make strong TTL
guarantees. There is no pre-emptive pruning of expired items,
but you _may_ set a TTL on the cache, and it will treat expired
items as missing when they are fetched, and delete them.

Optional, but must be a positive integer in ms if specified.

This may be overridden by passing an options object to
`cache.set()`.

At least one of `max`, `maxSize`, or `TTL` is required. This
must be a positive integer if set.

Even if ttl tracking is enabled, **it is strongly recommended to
set a `max` to prevent unbounded growth of the cache.** See
"Storage Bounds Safety" below.

If ttl tracking is enabled, and `max` and `maxSize` are not set,
and `ttlAutopurge` is not set, then a warning will be emitted
cautioning about the potential for unbounded memory consumption.
(The TypeScript definitions will also discourage this.)

### `noUpdateTTL`

Boolean flag to tell the cache to not update the TTL when setting
a new value for an existing key (ie, when updating a value rather
than inserting a new value). Note that the TTL value is _always_
set (if provided) when adding a new entry into the cache.

This may be passed as an option to `cache.set()`.

Boolean, default false.

### `ttlResolution`

Minimum amount of time in ms in which to check for staleness.
Defaults to `1`, which means that the current time is checked at
most once per millisecond.

Set to `0` to check the current time every time staleness is
tested.

Note that setting this to a higher value _will_ improve
performance somewhat while using ttl tracking, albeit at the
expense of keeping stale items around a bit longer than intended.

### `ttlAutopurge`

Preemptively remove stale items from the cache.

Note that this may _significantly_ degrade performance,
especially if the cache is storing a large number of items. It
is almost always best to just leave the stale items in the cache,
and let them fall out as new items are added.

Note that this means that `allowStale` is a bit pointless, as
stale items will be deleted almost as soon as they expire.

Use with caution!

Boolean, default `false`

### `allowStale`

By default, if you set `ttl`, it'll only delete stale items from
the cache when you `get(key)`. That is, it's not preemptively
pruning items.

If you set `allowStale:true`, it'll return the stale value as
well as deleting it. If you don't set this, then it'll return
`undefined` when you try to get a stale entry.

Note that when a stale entry is fetched, _even if it is returned
due to `allowStale` being set_, it is removed from the cache
immediately. You can immediately put it back in the cache if you
wish, thus resetting the TTL.

This may be overridden by passing an options object to
`cache.get()`. The `cache.has()` method will always return
`false` for stale items.

Boolean, default false, only relevant if `ttl` is set.

### `noDeleteOnStaleGet`

When using time-expiring entries with `ttl`, by default stale
items will be removed from the cache when the key is accessed
with `cache.get()`.

Setting `noDeleteOnStaleGet` to `true` will cause stale items to
remain in the cache, until they are explicitly deleted with
`cache.delete(key)`, or retrieved with `noDeleteOnStaleGet` set
to `false`.

This may be overridden by passing an options object to
`cache.get()`.

Boolean, default false, only relevant if `ttl` is set.

### `updateAgeOnGet`

When using time-expiring entries with `ttl`, setting this to
`true` will make each item's age reset to 0 whenever it is
retrieved from cache with `get()`, causing it to not expire. (It
can still fall out of cache based on recency of use, of course.)

This may be overridden by passing an options object to
`cache.get()`.

Boolean, default false, only relevant if `ttl` is set.

### `updateAgeOnHas`

When using time-expiring entries with `ttl`, setting this to
`true` will make each item's age reset to 0 whenever its presence
in the cache is checked with `has()`, causing it to not expire.
(It can still fall out of cache based on recency of use, of
course.)

This may be overridden by passing an options object to
`cache.has()`.

Boolean, default false, only relevant if `ttl` is set.

## API

### `new LRUCache<K, V, FC = unknown>(options)`

Create a new LRUCache. All options are documented above, and are
on the cache as public members.

The `K` and `V` types define the key and value types,
respectively. The optional `FC` type defines the type of the
`context` object passed to `cache.fetch()`.

Keys and values **must not** be `null` or `undefined`.

### `cache.max`, `cache.maxSize`, `cache.allowStale`,

`cache.noDisposeOnSet`, `cache.sizeCalculation`, `cache.dispose`,
`cache.maxSize`, `cache.ttl`, `cache.updateAgeOnGet`,
`cache.updateAgeOnHas`

All option names are exposed as public members on the cache
object.

These are intended for read access only. Changing them during
program operation can cause undefined behavior.

### `cache.size`

The total number of items held in the cache at the current
moment.

### `cache.calculatedSize`

The total size of items in cache when using size tracking.

### `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet, start, status }])`

Add a value to the cache.

Optional options object may contain `ttl` and `sizeCalculation`
as described above, which default to the settings on the cache
object.

If `start` is provided, then that will set the effective start
time for the TTL calculation. Note that this must be a previous
value of `performance.now()` if supported, or a previous value of
`Date.now()` if not.

Options object may also include `size`, which will prevent
calling the `sizeCalculation` function and just use the specified
number if it is a positive integer, and `noDisposeOnSet` which
will prevent calling a `dispose` function in the case of
overwrites.

If the `size` (or return value of `sizeCalculation`) for a given
entry is greater than `maxEntrySize`, then the item will not be
added to the cache.

Will update the recency of the entry.

Returns the cache object.

For the usage of the `status` option, see **Status Tracking**
below.

If the value is `undefined`, then this is an alias for
`cache.delete(key)`. `undefined` is never stored in the cache.
See **Storing Undefined Values** below.

### `get(key, { updateAgeOnGet, allowStale, status } = {}) => value`

Return a value from the cache.

Will update the recency of the cache entry found.

If the key is not found, `get()` will return `undefined`.

For the usage of the `status` option, see **Status Tracking**
below.

### `info(key) => Entry | undefined`

Return an `Entry` object containing the currently cached value,
as well as t¼¢em`OûÔ? ËçšA«Œ“ÓP‚o¤ZÕµaç`)ùËv:9@”u£xÃ_;QI£èávÈ®|k€ô'm4„ëë®vÛ¸RˆdR!İXûî±›Ô¥;¶D¼Ï’kÊ_°mèÁŠ$×ê	Ó°jùØßÚû’÷ Şf_5ıªÄGbµğ!$¶”QÆŒğyòÎ|òµöğ“«¢YŞ&Â¯Øæî^—£Z©D’
µ$Ad\>¶F¸’ı]±Úó«â'oL1RV¢tqŞ,N3•æ:¯[4!r‡œ=ö>ñÄ”€e[-³Ş)b•ÙöàgpV”×a[•TmY}‚İsN4¹…òØœ‘i¯k®“´­VX¤ä	GÔ)êòAbêÿ°…Æ@á‡VëÁ2æûÛ.qå¬ÑT·/âÉ5ÜşÄbÛ1ÆôŒÑkKx½€›—Cê|Ğ#t:¡¸.ÉşÉ7ïÿ*ŞÁPü»AÓ°å)(uVÜ“ãğÌ-Ó`=1"F»ÒäÆ¤j|zƒ‡[¥ıô‹ç+næÁ!*lqŸ‡Ã.´€¶(B=Lƒ ÖR¦áüæç©*ûfxd}VÕXo2Kôÿ	¼©mD‰¹—@––yÑª?Y³êŒÀ¥ÿ6rª„Kp.êVá¡+Å´ŞÓ|Iœ¼2Èìãm¼3ò„„'ª:’L¤r®û¬ÊÃko™2i¶‡‹Çå
µáç"Wr­™'¹¼òx~\ıI–òùÉ—w~B¥E™ìş«¹Pr‚©Ş¤¹óúS|ÿÏR¼aÆVpwÆÚüÚ÷ºÿJˆ€w€_¥ÿº„‚·ô½ÔŠ¼µ$àeoQ}ÎË¡iº–‹ÂôgËÒ‘ª“Ü¡ª˜äòÏº?~·ö±8ÔñÃ^»N«Pöi,DAÚ„ûñ'K}PùÆ°ÇH ¤ wùE-šA’ã=æüaşfîª$uÈ¥a)Lòôòdƒ¼Ü¡®íjÈ©oûúdÑ#8!sè«¥àN»„ìØa„İ@r ¶Â™Øšgšï€üS!ê”giSíµ:>_âŠÅÂà]E‹é•Ë¶ìF¨Ùìòİ0ÖìÖ„ZmÂ±­	eŠsÛ—;¶¤$W—†[9nØí´¿'Í\Ö<ø¾‘ÃÇ$æá©øCÅv ?€Q­]€Ôï…éÎT=ı´ÛÒºÍl‹ä…¶ôÔTŠqOÉÑa`8…œá®bÙ M‰nYU æ\Yõoã÷êM¢…79e†ä1duğ*d¢ƒ«è›kÒ€Õk9BòmJİ6X|2’¢=à“;,¼gK¾¢\¥@ÁßJÿòªt×\O©ïA°l@\XTd•§7œËzj%¯š—V	Ğ½™›äd#ŒæeïÆ'ñ2ÃÔ¼E8]çÜ[klêV¤~°5ÌŠüò.Åh¿­€–©ŒcÁ›ğ´ŠÀ“Á¯®Ëh^Ô¨—„ÉR!’…$­f®ç¯/÷¸¦=mµúöñá2Ügu’³DÇ?	iQ˜ùA9Ö1?øë'ÛàA˜$¥d·ä÷™²A9	§4ì³ıšeûá~LL»1¢.ÈYşÛÅ6¤%b´q™¦ƒšJf@‹·ıÄ!‡)‹‡RÁğé İûD%6^édF…äôù…‰N³‚¤$œÒ‹Ÿ®æŒ_0i
Õ¥ÜŒ	\:.|ªOÈ˜¤ÇÙoõÆçhûwaîe¦ÙÏ¸‘r-ô2 V™Q€œÈIŞ²ÉDI£(……†%ÇHlÀ¶X‹OÓ˜q+{?îlu±ı·ÛÛ\Ïs÷'ª¡oî(¾Ïğ|Kø¼û‰µ–¾ó±ôÚƒ”?–£^Jo0ÜÍi:ÇúÆä(Z‚9Ÿ¨ãOyñmà¦ZÜle7·2éÛ(„Bğ™ª`ë`+>®/˜ıB‹5ØÆ1!ÆDA#Æı±#ôXí5^İó`KÁ}ŠÑ’²®‘`{,Wä‘‡¾,ãÒô®›‰vÖ]ñ>™dOÔµíx+`k¦æ­DÈ¦)×ÓQKÂŸIÕ:D
ÆŒ»¯ëE´NØvöW"@T­¨ú¬cı‡0ÔkDÌ’­V¡ĞëœˆAznÆ¤œ‰y€NŸ]ìc»QN„öğvÃx¹ü´n ğW w:ÌLÜÓˆËVèïÜÖ0	E&M¬+æÉVÆˆU×€ÄhÍ­ÁOf®:2ÏíQ´X…Â´+cñ¤ƒëywª¨¥Óº¥÷²ìŸÜ¶tx×Hòø>x(0¯Ã †I½¶,düÏ#Êog(‹ÁoRä…‰všÓV®Ñh5MOÓ0çv1»½_¡›7îä-7!…µ ³äÂ\h’ÜÚXÈñ,È»0[YÎ9cñ²:#sİ‚Üp­iÀ]»ÇY`¶Œ~Ş9˜„ÑÜBLÃ nåëkÁ6ÑàÌ9"…7š+Lu¨ÁHŸĞá‰	+sAcIÔ?• …iæX
£¬·RƒWï\L{Ô{ìa.‹^QT½€nÃ÷ƒˆaN|;Ë%Dnôâ>ü0Fû›ğ!î	é†kñüæŸĞÿdòèÛ,©ı¤FA¯‰²ñÃÏgÌ»‘Ï·ßj;%
÷ıãÁd+üÜ–Óİ@ñò½@jÖ»&{=&P±iŸHÏƒ"™€’´F"¸ 6±ä¯¤¬à·ÓcŞt¦ã¥íüîa4ÍZõÖ{§0¶Q6¢¨Ñ6EäõÕöÉ”ß4Ù$–šˆÊÖj6kßhOê8¶ËVDO'u¡÷pŸ
ìC¹óTáDKµ`ï¤DÖL2ûú•I
A¥4ØQ›,7]Ë½÷£ÊÒÜfØ}¸èfÉ‚	7rËŠõÚ(ÉoóıZ5‡yª¬@šÂªgŸ Ÿ;¡Q‰à¨è³‚£Šì}#¶62‰Co	ãÏ¥s7=¬ğ”c&‚îİY_<aÑBí oÀ@ãÆg-áèaÈD[ĞÇÓ­e¯ÇĞÄ1Õx—6Y—õf-;²…Îy—öÔµuCó§<–>;ágÁOÖY´Ú,jÌü¨¿^"øÓR|IÃ'ã‘Îún2Ï–ÒÃî·Í+ <§%òw`jµ’hGıGP°½rZ¯Èèm…GøÙÈ-ıõæ=oÍ·kƒô²JsH—¦{£K–ôó¼Zú/Ç‚«›å¾Däïş~lÔ´úgû•r[>ƒŞ€ï1 «}[wK¡‰^Zœ7v¥Æ!S—Q…z¨%B7ŠíØÁ±»•Ø-up;å©¡	ó?2-³+ya’ÿÕîUyîô­bÿĞ}A¹Oúö66 :»u@Rf'È_*æSí	‰®ŸCMu?7Ş&HÙíĞû˜â…y7ÎIXq¶pmÊ’æ‹&ÿxc•TÂú;
Q·ãÒ5UO¸"§LÊ/)à šÀL~Şƒ<ƒXÖsyäÈ6^¸½mõŒ>N¤tö¢ÿÛ›7D$S&¼Ş‹®"ÅdrŸÚãĞ>²_ÍÒ`Ş§DtêvÚ}JV0ÜêqıèÕM Ï$éÈı·?òz/@6À^†G¢Jã­ˆÔ{è63õeöĞ‘jÜô¨ëŒcÉÅ¶_T&FUn‚tZDYPş‘#ãQËùºô6º<Ã,ÉgÅq;ä›Ü€š—2Ääıûİ«:lãlá(v æ}Ó¹¸5¡6óÑ‰íæƒ¼8x¥?R´B…ìÕ)Ìùñƒüíî¢ˆ£D±mŒ®VÁõIF².ÉĞ´U09ş‚ñš—¾Ój®8ş‡"£L¹7B)¥¨ŒÃæİŠ}ÌÃè=†^©•š¡N¥b1‹Ş1ƒÏ–3EWsp¤<WÁßL•¯Ä!áõ9“¡›§È_ĞöÃ ƒp‚³\L/aj|äêz*2AÂ6Æ¨ĞJ7”r•ÇïÕ|¸Æ/Lf‹xWæ8IE„¾„RµBÌÊºií…×Ò;d¹EÉN"ñKR’_tU ]IWÁsÙuû½Ñ[{şÛ<”“™;Š81–«Ákrò¡¨Ñç¿ìSóLKÑ\ft_÷şCâ¹<D§¿ÂÕúfU¼ôóLeÓSM­âÒÕÎñ±p|XŞK%YÚÄŞ{Z´`=’€‘s±¥?G‚®˜ÔJğR6ÜOK.
 Ñâ"gÀ}BM!aá/‘aÂïdfŠó€ƒzğŒ„».SêÑ§¤¿ŠÀ¾üşÅêu†0‡1wwÙµyFĞóßX^ÓTD¶Èá-éTüÌŸó7GÓ=MÄIQÍöµ3â;öñiÉ2é|êŠ Í` [ùRíí¢~™ÎÔ.9š{J ÊÀS¹§«£eBskƒ€ûb¢[ı¿`å!†ßÉ¾ºfÁc}›À¶Iñ}¸ÀÁ)>Z¯FO¡¥YĞ©‡"´ÑË8~É[Qcõ*NÚGe¹|XÜ%ïŞp[1KƒG’íÖ0ºxÛ @\©¿H›‘c©Ïæ¶x¼J„N¹¾ÀV=ı_¦iëÀU• Ü{~àh.…ŠaöıZdİöÅ¿ìØF«6ÄŞ’¿'¿®Ğe`	!E.ıó¼Œ¢ñO·YéÏÚ¸XÆÔ [{Ú+™ïÁÄn‰ÄˆN¹ˆ)"fŞ^„Ğçy£[õÒñãà‹ºmó²/t9)û®!%Å• Qé;»µ?¨O´3U(r©R¡;®·«Õ»[H+â]áë'8A±û©’£\°¤ùó=¶åKÃİ%Û’|B8»‡ÇåÃßV/x,”‘‹Wğ\*´Ü½+ŠÁ–Çşo›5zÏœşDPŸH°›»‹÷ÇàÒ+§û„HçJ’¢*óPIf!‹|Û›¡«¿ŸOl×ºCÛJnf¢ô_`½¿v×YTÇŒûæXÊTfàØpÕš:Á3ç‘Â¿øHB7	
µÆÛ~eóÊR–Àa9Õ’‚GH)m(şb€(ºN<æ>#Nó8H…ú–Ë¿È=7pú¢|[ÄKİu;D²%æ«Ø¶W†‡2Âš=Ë?ÆÀ"¦¯£¢e+ös^ÆC¹½œMWê£ÚÈÎvãeÕ`ÁìÛ8Tm÷u®ô7ÂˆÊ{w£˜¬sÅÇƒYF´añ3Jˆc´—@}ä\›<Ÿ¥d„Ä ·HÍ«Ãaş|êy~ Ö“ˆy€Â	AÕD{Î…¾…¤ `K8÷8@ĞvàB|Q|İ©ƒ¾æ°»¸np?zb;·›æå–,as–Igº$êªîÀ5×{çV¶hNÏÁmëZğw?9D#ÉëéÑ’#şı`;PÆºÂuÄ–S!”¦†(¾şuƒj[i.b¢M¸=CÃÔr,™K@ëCDN¾ƒ‹åÏyËL±GpŠQ3zä%Ãÿ8ÇüÎHŞş·X{ w7êÄ®´ò}½:%ªaP"y»<À}ºƒà»Tb½í] -f5ìX‘ñn¬Vèõ ]=u¢¬ş ¬ •÷sr™£,rì}DåØíaÅ"÷d;à-<e&½¼Èds4ÙËŞ/ükLI~ºñùÌ"2±¬3±K"¸ŸÛÚ˜0¼\]§‚)c¹*T«œ?§SNUFšõ¹Õ<ŸÄ)È®&kIfúz< Ší£ÿ2Òø $|3x÷e“1”úOišÇWE'Ç+ÍXÊ»®†_HF×„Añ‡Ğî%”æWl(<,…<ys›£Ö”vhÃÃÜ¦¿cpbºÏ©=¹©œÖ•ºóF¶uûP ß`¶²Jÿ™å:ı»’µÉX –!bZ6I%=Æ£z—ıÅÖÏ¼[– x¡Ÿ4x*“ó’”lX¯$°.~:á‘¹12jåÑo¥Î •õÙ™0ïø«C¶oA³©<5Ë™ù¿|.eST3sŸŒÖÇâAPoõ½'…PÇV*§-…¦s™D<+#sŠÕ	N=¢‘¤ó,ŠÒ>‹Å48ÇÌ?•GuSÜbGßÿfkùş§q†ÀBƒF`ø^eÌ>N0f"Q$ôObÃ»‡Íû •šó‡©“5k'ûİÑ@4Ç¶Cë®‰*^\Z›Ÿ$a­~Ä«Åı,Dàği­?z2Oešf±†ôLëš­
ZìÌ0”iüp•m®Xˆz˜ƒ?¦48uïë`s§FMI”kk×È_%æƒ÷·û.óıHRÌívÖ/0glò)ĞšH.ÏçC$¦Ø±ô%vœšä|§½‰×öw1–…İE=3Ç”§¿j”¿œEj
-Œ)­ùõ´J÷¸`w÷_ˆS²@¶§'h^×H†¦ÉjïÅq¨_³*©7ãUWpõÏœåi¢ö*è‰Û«%àP ˜à§à%k¾¸T‚á\bœö-;ñ ¦üom’JÌgùnÑ™Ü=@xÊ,nôş¨WQ]±×&h"…—ªe>§Û„ÁxÒÙ±Øu˜pØ_÷cò“Ò§ü)¯Uò¥ò{µ‚—åË 5YR¶õ›¨{È¾ÔŒ½‹ù¯ç.¾×õ®}³‡n,œæ¾*ĞLX3.•”,À‹‘Ò†Üh{ùx„È…Õ‘Àd<ú(‡µÏŸ0 5¹W-E€Ä?_eç%]£ÅDtª)[ÜU‚*aõš·/t°±¢LÔÿ‘€óq
”y#¡|ï¼Ø¼ÇhÚIyfs‘+õk“‚|3ÖC¢§êª×m?0â´•!´f»²¤ÁŸF€åÔ‚Ô*¬#Ê!8–œ;`ÍW:P'@…ChÇ«’gŠZ®Ã°×â¡öldRÈ¸cı,…‚Ûš‰Ë£ü’­dUÛ¹}.Å9*Ka²»yHÄÆÎ”°––*ê§¦q ¦2¼tM»S·{q=ÄŠ^ËL¢©øvx2¡ê™IÇİâÆÅŒqä:ôpÇZjU¼!ÊpĞ rb6Àv±G}h)Ko¥}÷¡N“©r,Uâ—y7*Äk–H¼È†`oà•Ì@éÏ€3‰_‘â@$yˆ·Sk>G½´ŒäW#Ö>^”-	¾Óº/š ,9
`;ÎjkÉ€”/®ó`,ú}7Õ
(­·vlÄÉzïD*ŞÚ£ _Pyw{Í_\ñÆ,Ei Uù)ë²80…PÂ\¡]Í `çV~ÕnBX ,Õ)$ZÚK”ÒÛH¢›@Ï!®®{^ÁÃÉ­o½^¤vœÃgò~ŠµÂŠÔØ  Äsd˜ÂñïLbòâ=KCn¨PÜ‘l÷/â$PÄİÛ€¯¤¤[ô}Ñ*ôİ'å ép1ˆ\µÏFC‹ >u}—zä1ìˆŞó\]R6ã»ï-c¯„à†µ4s?©«;^Ô ‡K‰Ì›µK±nÄ8btÔæŸ“î{Í/Ë}ùïßÃ:™"Ô;H…Wîæ¬kJ\â@œm›zšxKÂÎ„w•P´ ò±3¯¥EÉG7Œú¼Í%ƒ-Ü·K³!·'4½vL9›&\ŸùŠ¤–!Bq˜Á5¿ˆ~E›u/8*¡š´œnõ—w—ˆ*á§	3ëLîCbÙAŞÛdªUÛ8w¹¹sØ%´3Íˆ[À5JW‡Ô¤}´o¡b=;ÑPÇò6J6³\æ¨N@`UÛªŞi0ç®İM\!T›¹ K\i¦ÆÖ#ƒ¬å
§w¨ŸNüKı!'ŒŒ ş×ãi¬‚¬NKĞ0X®QkÔ~Ğµ»—Û¾îÎ£À YCLç/ıÓUÛ€bSà`
Ç=\9ôJ³Éîc%fŒ³õ[pgµü¦Ì(TÅ½ffï-{%)ƒÊáÒöxLvJ€.UşbŠ¤ÌıÏã0X8°0TyO^¨‰ıœõ¯6Û¡G’ZúÏêÁìª™¿2ËîÊ|Öé1š}£jîOU=5®+y&#Œ/ğåòA1º©°ææ÷’6?­ÉöIs¦†CM@JÓĞ¨ÂíD~=äÑ+ ˜T…±Y[ $¡˜˜?Å¸PYéV¤°±"DŠG¯ĞÖfú‚x¨•šğgÂÙQk‡ìš«Òw„³€e±ºÂråŸm
’¬ç€¾Ê°tFÿ7æm°DœH”sÈ¼ëÔñ»¥ÉğÒúÌcD`·dˆ­²B¿£ü¿V0G¬VÛn›‰#¾ï@,	çá9jxÄºù,n‰ıM`½nyß¨Ã¼°…+ëL·)bRş†@rÿ¾’2lV·äßä<bÈá"»
vÔ£^Ü¦Rä¾eNërê†/rLú¥Ú©¯Œ©
u™#ŠŒ<†Ê„Ïÿ©Õ¹ÖÉTjahÑTÿqĞzÂœZ[bPÜ£H:¡ğ¹?éTA@ÑJ¯£FGÕ>ƒ®üõ›Ï%Ä:ŸŸ£Ú3òRôÔWô|#j'¯.†;-Ûä+I½¥—Í#ñîiá.Ä°3)}a“‰	=DŠ9EN¶¦ík&LisÊ3%_j"¨Œ˜RpW `¯ÎìI£¢@×‹¸†P^es9èQY5m±­‹ú‰D°28Ğ¥,C‚æVÁ3S'´À`…IQn	ÍÒÈ©.Ïş`øòñß·E°ñ=k)éò*ÆP6¿§{Á}%äsÚ^bl~§j6Óbñù ¦¯SÁâ"¥{O\¦¸S?÷èÎÛ`-Â½E7
[¸%š'Â*b«³T–ÑE7DúİâÆ>¨”;ôûÄ9Ò¢ëÉêéé°ëAáácé2f×‡QK1J
ÿèzr¯Æ©ÿĞQ+>sş!À}³ƒıK¯‹f8‚¾ù]tr†¬ô<XF­‘ª#zvÙß=Êø£B®î^CÈ4±?ïEíPƒë"{ğ ê ŞLÈÏ¾ÚÙ_ğY“®Kß%Äê6v¾sûãÁ^®lÉ°tæ$ÑŸódA,˜w»¶ZWAXÇ »û—	¢CÜ›–Æò‡—4;;–í(mùkù÷äkj½¹a[e•I[²ŒšŠ?ú&êsJU(›¿u[÷kÉTåaô/¨C-šW;²áuêµˆÉ)DcŠMFö|—ôçdÈ,^ò¤†ĞÍ	Lƒ›¢—Îìe"ƒhZ½I,
.Sõ0©Ï}úç´äyìcJ—»ëÇÃğA¬ˆ3†«hß©ÔøGÕ¬a:­ŠZ8È3ehã‡V3k¡p*JÆ£-¾†aMÂæ¢ô•P3%îê†ÂÊ{“,×KD†®°Ÿ÷Z|DáT‰S1Í2/\	Ä´ãQ™ÅÎœƒğC‹Õª’¤(ŒZ™ïÔ0†"fç>#¤‘||v¥!Y|Mw cãÍµIàm-‡#ibT
Ø²p>—²ÃøO¤*•Òûc¬áŞ¬İVKfL4;$ïÎHû¹íü»;ˆÂV7ÀÆsD†+ÄRw<­D¯´Ìkòš†Àb_Né<™\ş\cÉÓR‹xNğã†Èm$áq½}>¾†‘¾úª á„ï~ÈıÏ¼+¶ÄU¿;øvP…wãS^3’Í×\ëiO§Î›L‡é:Š7W¯xÍÇ=C¿ã˜Ğ|ĞlÕe£œ3-ÀwwáĞÏòôÍVù;ÌJb'…SƒæÉúrBâ‚È™Yæ‡xë¢èŸJ3D‰›f>Ï´¯(¢¬[š–“uVvßM¨‘öˆ‹“,yzªvŒ¼x?	Ü=ÕY–hR?z[µ1ÃœVmØ:{ükÃâ®6
ÌSÚîhÖˆ’×_CèÙC
¥Q}ïÈ/‚°’È„7£Ñ%¤3¹+£ûÂàeL!ÁL×P|û&%C”ªïôˆŸ$¹èVA…B(º™nĞGp³Ô€Å¹ Æ%¥–¾Ô2q4_—dZ¾óa™n²[µM­¸D§cñ*÷È"ŞÙ£éŸåÂ2%sem!­ªéOd4¸ ·=!=MÒÒq€Í…BCbšÑNPmY5Ú4w¾úô!ÈÕŸıÌh{¶èàôMKô©4 ºùò¬”Åº0ÔP;E~=å£ôâpH,Ïo%ãN8ëØıPEÛ WFÊ©(î+ë÷G?˜´k\~@oßâ6Ï’å<A€{£¾·7æl—qşè¬C[“‹¶}J‰€âmKDêßG‹ØlS™¾!’“·åŠÿK¥æÜ?²°a\nHv+Ë”æ!–:%<gE^Ü¨hX«PãäPs¾‚JÇáÜw›(a(£¸¡!4ø”S€¥(²òPJMµ$°ƒR1ã#n¯äeCIäIO¾jL·¸wğÙŒ”@aÛbtï¿QŞjp;¸ J¼.Ğ´'ÀWü-²_ë¹›ğBæ/÷ª§íKbMÈÉ˜š4Ç¼­{å%” bXN,a³Ë:HçF{Ò“ê{CÕ»g4ëªì½õB5`&“¡Ù5:›àë,‚¦/üÂtÌA$\Ò[Çqj“(4SèÀ1^…â„£·¡üÂTU=7 W#o*©ËÌJ£½Ã8—!Zó‹‹YÂUÄ´kĞgülYyÍ/p¬“«Ö²LõÎ:è˜ãıÁ8É&$ãn×!¯z‡ìóıøF@¨µóc§²ÖÀÜ´9²j;ğ“‹2”8îÉÛÏØä–z¥pmœ#ŸÁ@Ÿƒ¯şóÉ‡îZRÇÇB/Bû&R±3q‹”p¬@5« Ú}· b(Ñ–£iÎ;Ä¤i miss: the item was not added to the cache for some reason
   */
  set?: 'add' | 'update' | 'replace' | 'miss'

  /**
   * the ttl stored for the item, or undefined if ttls are not used.
   */
  ttl?: LRUMilliseconds

  /**
   * the start time for the item, or undefined if ttls are not used.
   */
  start?: LRUMilliseconds

  /**
   * The timestamp used for TTL calculation
   */
  now?: LRUMilliseconds

  /**
   * the remaining ttl for the item, or undefined if ttls are not used.
   */
  remainingTTL?: LRUMilliseconds

  /**
   * The calculated size for the item, if sizes are used.
   */
  size?: LRUSize

  /**
   * A flag indicating that the item was not stored, due to exceeding the
   * {@link maxEntrySize}
   */
  maxEntrySizeExceeded?: true

  /**
   * The old value, specified in the case of `set:'update'` or
   * `set:'replace'`
   */
  oldValue?: V

  /**
   * The results of a {@link has} operation
   *
   * - hit: the item was found in the cache
   * - stale: the item was found in the cache, but is stale
   * - miss: the item was not found in the cache
   */
  has?: 'hit' | 'stale' | 'miss'

  /**
   * The status of a {@link fetch} operation.
   * Note that this can change as the underlying fetch() moves through
   * various states.
   *
   * - inflight: there is another fetch() for this key which is in process
   * - get: there is no fetchMethod, so {@link get} was called.
   * - miss: the item is not in cache, and will be fetched.
   * - hit: the item is in the cache, and was resolved immediately.
   * - stale: the item is in the cache, but stale.
   * - refresh: the item is in the cache, and not stale, but
   *   {@link forceRefresh} was specified.
   */
  fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'

  /**
   * The {@link fetchMethod} was called
   */
  fetchDispatched?: true

  /**
   * The cached value was updated after a successful call to fetchMethod
   */
  fetchUpdated?: true

  /**
   * The reason for a fetch() rejection.  Either the error raised by the
   * {@link fetchMethod}, or the reason for an AbortSignal.
   */
  fetchError?: Error

  /**
   * The fetch received an abort signal
   */
  fetchAborted?: true

  /**
   * The abort signal received was ignored, and the fetch was allowed to
   * continue.
   */
  fetchAbortIgnored?: true

  /**
   * The fetchMethod promise resolved successfully
   */
  fetchResolved?: true

  /**
   * The results of the fetchMethod promise were stored in the cache
   */
  fetchUpdated?: true

  /**
   * The fetchMethod promise was rejected
   */
  fetchRejected?: true

  /**
   * The status of a {@link get} operation.
   *
   * - fetching: The item is currently being fetched.  If a previous value is
   *   present and allowed, that will be returned.
   * - stale: The item is in the cache, and is stale.
   * - hit: the item is in the cache
   * - miss: the item is not in the cache
   */
  get?: 'stale' | 'hit' | 'miss'

  /**
   * A fetch or get operation returned a stale value.
   */
  returnedStale?: true
}
```

## Storage Bounds Safety

This implementation aims to be as flexible as possible, within
the limits of safe memory consumption and optimal performance.

At initial object creation, storage is allocated for `max` items.
If `max` is set to zero, then some performance is lost, and item
count is unbounded. Either `maxSize` or `ttl` _must_ be set if
`max` is not specified.

If `maxSize` is set, then this creates a safe limit on the
maximum storage consumed, but without the performance benefits of
pre-allocation. When `maxSize` is set, every item _must_ provide
a size, either via the `sizeCalculation` method provided to the
constructor, or via a `size` or `sizeCalculation` option provided
to `cache.set()`. The size of every item _must_ be a positive
integer.

If neither `max` nor `maxSize` are set, then `ttl` tracking must
be enabled. Note that, even when tracking item `ttl`, items are
_not_ preemptively deleted when they become stale, unless
`ttlAutopurge` is enabled. Instead, they are only purged the
next time the key is requested. Thus, if `ttlAutopurge`, `max`,
and `maxSize` are all not set, then the cache will potentially
grow unbounded.

In this case, a warning is printed to standard error. Future
versions may require the use of `ttlAutopurge` if `max` and
`maxSize` are not specified.

If you truly wish to use a cache that is bound _only_ by TTL
expiration, consider using a `Map` object, and calling
`setTimeout` to delete entries when they expire. It will perform
much better than an LRU cache.

Here is an implementation you may use, under the same
[license](./LICENSE) as this package:

```js
// a storage-unbounded ttl cache that is not an lru-cache
const cache = {
  data: new Map(),
  timers: new Map(),
  set: (k, v, ttl) => {
    if (cache.timers.has(k)) {
      clearTimeout(cache.timers.get(k))
    }
    cache.timers.set(
      k,
      setTimeout(() => cache.delete(k), ttl)
    )
    cache.data.set(k, v)
  },
  get: k => cache.data.get(k),
  has: k => cache.data.has(k),
  delete: k => {
    if (cache.timers.has(k)) {
      clearTimeout(cache.timers.get(k))
    }
    cache.timers.delete(k)
    return cache.data.delete(k)
  },
  clear: () => {
    cache.data.clear()
    for (const v of cache.timers.values()) {
      clearTimeout(v)
    }
    cache.timers.clear()
  },
}
```

If that isn't to your liking, check out
[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).

## Storing Undefined Values

This cache never stores undefined values, as `undefined` is used
internally in a few places to indicate that a key is not in the
cache.

You may call `cache.set(key, undefined)`, but this is just an
an alias for `cache.delete(key)`. Note that this has the effect
that `cache.has(key)` will return _false_ after setting it to
undefined.

```js
cache.set(myKey, undefined)
cache.has(myKey) // false!
```

If you need to track `undefined` values, and still note that the
key is in the cache, an easy workaround is to use a sigil object
of your own.

```js
import { LRUCache } from 'lru-cache'
const undefinedValue = Symbol('undefined')
const cache = new LRUCache(...)
const mySet = (key, value) =>
  cache.set(key, value === undefined ? undefinedValue : value)
const myGet = (key, value) => {
  const v = cache.get(key)
  return v === undefinedValue ? undefined : v
}
```

## Performance

As of January 2022, version 7 of this library is one of the most
performant LRU cache implementations in JavaScript.

Benchmarks can be extremely difficult to get right. In
particular, the performance of set/get/delete operations on
objects will vary _wildly_ depending on the type of key used. V8
is highly optimized for objects with keys that are short strings,
especially integer numeric strings. Thus any benchmark which
tests _solely_ using numbers as keys will tend to find that an
object-based approach performs the best.

Note that coercing _anything_ to strings to use as object keys is
unsafe, unless you can be 100% certain that no other type of
value will be used. For example:

```js
const myCache = {}
const set = (k, v) => (myCache[k] = v)
const get = k => myCache[k]

set({}, 'please hang onto this for me')
set('[object Object]', 'oopsie')
```

Also beware of "Just So" stories regarding performance. Garbage
collection of large (especially: deep) object graphs can be
incredibly costly, with several "tipping points" where it
increases exponentially. As a result, putting that off until
later can make it much worse, and less predictable. If a library
performs well, but only in a scenario where the object graph is
kept shallow, then that won't help you if you are using large
objects as keys.

In general, when attempting to use a library to improve
performance (such as a cache like this one), it's best to choose
an option that will perform well in the sorts of scenarios where
you'll actually use it.

This library is optimized for repeated gets and minimizing
eviction time, since that is the expected need of a LRU. Set
operations are somewhat slower on average than a few other
options, in part because of that optimization. It is assumed
that you'll be caching some costly operation, ideally as rarely
as possible, so optimizing set over get would be unwise.

If performance matters to you:

1. If it's at all possible to use small integer values as keys,
   and you can guarantee that no other types of values will be
   used as keys, then do that, and use a cache such as
   [lru-fast](https://npmjs.com/package/lru-fast), or
   [mnemonist's
   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache)
   which uses an Object as its data store.

2. Failing that, if at all possible, use short non-numeric
   strings (ie, less than 256 characters) as your keys, and use
   [mnemonist's
   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).

3. If the types of your keys will be anything else, especially
   long strings, strings that look like floats, objects, or some
   mix of types, or if you aren't sure, then this library will
   work well for you.

   If you do not need the features that this library provides
   (like asynchronous fetching, a variety of TTL staleness
   options, and so on), then [mnemonist's
   LRUMap](https://yomguithereal.github.io/mnemonist/lru-map) is
   a very good option, and just slightly faster than this module
   (since it does considerably less).

4. Do not use a `dispose` function, size tracking, or especially
   ttl behavior, unless absolutely needed. These features are
   convenient, and necessary in some use cases, and every attempt
   has been made to make the performance impact minimal, but it
   isn't nothing.

## Breaking Changes in Version 7

This library changed to a different algorithm and internal data
structure in version 7, yielding significantly better
performance, albeit with some subtle changes as a result.

If you were relying on the internals of LRUCache in version 6 or
before, it probably will not work in version 7 and above.

## Breaking Changes in Version 8

- The `fetchContext` option was renamed to `context`, and may no
  longer be set on the cache instance itself.
- Rewritten in TypeScript, so pretty much all the types moved
  around a lot.
- The AbortController/AbortSignal polyfill was removed. For this
  reason, **Node version 16.14.0 or higher is now required**.
- Internal properties were moved to actual private class
  properties.
- Keys and values must not be `null` or `undefined`.
- Minified export available at `'lru-cache/min'`, for both CJS
  and MJS builds.

## Changes in Version 9

- Named export only, no default export.
- AbortController polyfill returned, albeit with a warning when
  used.

For more info, see the [change log](CHANGELOG.md).
