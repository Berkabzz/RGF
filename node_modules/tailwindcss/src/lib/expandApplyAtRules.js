import postcss from 'postcss'
import parser from 'postcss-selector-parser'

import { resolveMatches } from './generateRules'
import escapeClassName from '../util/escapeClassName'
import { applyImportantSelector } from '../util/applyImportantSelector'
import { movePseudos } from '../util/pseudoElements'

/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */

function extractClasses(node) {
  /** @type {Map<string, Set<string>>} */
  let groups = new Map()

  let container = postcss.root({ nodes: [node.clone()] })

  container.walkRules((rule) => {
    parser((selectors) => {
      selectors.walkClasses((classSelector) => {
        let parentSelector = classSelector.parent.toString()

        let classes = groups.get(parentSelector)
        if (!classes) {
          groups.set(parentSelector, (classes = new Set()))
        }

        classes.add(classSelector.value)
      })
    }).processSync(rule.selector)
  })

  let normalizedGroups = Array.from(groups.values(), (classes) => Array.from(classes))
  let classes = normalizedGroups.flat()

  return Object.assign(classes, { groups: normalizedGroups })
}

let selectorExtractor = parser()

/**
 * @param {string} ruleSelectors
 */
function extractSelectors(ruleSelectors) {
  return selectorExtractor.astSync(ruleSelectors)
}

function extractBaseCandidates(candidates, separator) {
  let baseClasses = new Set()

  for (let candidate of candidates) {
    baseClasses.add(candidate.split(separator).pop())
  }

  return Array.from(baseClasses)
}

function prefix(context, selector) {
  let prefix = context.tailwindConfig.prefix
  return typeof prefix === 'function' ? prefix(selector) : prefix + selector
}

function* pathToRoot(node) {
  yield node
  while (node.parent) {
    yield node.parent
    node = node.parent
  }
}

/**
 * Only clone the node itself and not its children
 *
 * @param {*} node
 * @param {*} overrides
 * @returns
 */
function shallowClone(node, overrides = {}) {
  let children = node.nodes
  node.nodes = []

  let tmp = node.clone(overrides)

  node.nodes = children

  return tmp
}

/**
 * Clone just the nodes all the way to the top that are required to represent
 * this singular rule in the tree.
 *
 * For example, if we have CSS like this:
 * ```css
 * @media (min-width: 768px) {
 *   @supports (display: grid) {
 *     .foo {
 *       display: grid;
 *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
 *     }
 *   }
 *
 *   @supports (backdrop-filter: blur(1px)) {
 *     .bar {
 *       backdrop-filter: blur(1px);
 *     }
 *   }
 *
 *   .baz {
 *     color: orange;
 *   }
 * }
 * ```
 *
 * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:
 *
 * ```css
 * @media (min-width: 768px) {
 *   @supports (backdrop-filter: blur(1px)) {
 *     .bar {
 *       backdrop-filter: blur(1px);
 *     }
 *   }
 * }
 * ```
 *
 * @param {import('postcss').Node} node
 */
function nestedClone(node) {
  for (let parent of pathToRoot(node)) {
    if (node === parent) {
      continue
    }

    if (parent.type === 'root') {
      break
    }

    node = shallowClone(parent, {
      nodes: [node],
    })
  }

  return node
}

/**
 * @param {import('postcss').Root} root
 */
function buildLocalApplyCache(root, context) {
  /** @type {ApplyCache} */
  let cache = new Map()

  root.walkRules((rule) => {
    // Ignore rules generated by Tailwind
    for (let node of pathToRoot(rule)) {
      if (node.raws.tailwind?.layer !== undefined) {
        return
      }
    }

    // Clone what's required to represent this singular rule in the tree
    let container = nestedClone(rule)
    let sort = context.offsets.create('user')

    for (let className of extractClasses(rule)) {
      let list = cache.get(className) || []
      cache.set(className, list)

      list.push([
        {
          layer: 'user',
          sort,
          important: false,
        },
        container,
      ])
    }
  })

  return cache
}

/**
 * @returns {ApplyCache}
 */
function buildApplyCache(applyCandidates, context) {
  for (let candidate of applyCandidates) {
    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
      continue
    }

    if (context.classCache.has(candidate)) {
      context.applyClassCache.set(
        candidate,
        context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()])
      )
      continue
    }

    let matches = Array.from(resolveMatches(candidate, context))

    if (matches.length === 0) {
      context.notClassCache.add(candidate)
      continue
    }

    context.applyClassCache.set(candidate, matches)
  }

  return context.applyClassCache
}

/**
 * Build a cache only when it's first used
 *
 * @param {() => ApplyCache} buildCacheFn
 * @returns {ApplyCache}
 */
function lazyCache(buildCacheFn) {
  let cache = null

  return {
    get: (name) => {
      cache = cache || buildCacheFn()

      return cache.get(name)
    },
    has: (name) => {
      cache = cache || buildCacheFn()

      return cache.has(name)
    },
  }
}

/**
 * Take a series of multiple caches and merge
 * them so they act like one large cache
 *
 * @param {ApplyCache[]} caches
 * @returns {ApplyCache}
 */
function combineCaches(caches) {
  return {
    get: (name) => caches.flatMap((cache) => cache.get(name) || []),
    has: (name) => caches.some((cache) => cache.has(name)),
  }
}

function extractApplyCandidates(params) {
  let candidates = params.split(/[\s\t\n]+/g)

  if (candidates[candidates.length - 1] === '!important') {
    return [candidates.slice(0, -1), true]
  }

  return [candidates, false]
}

function processApply(root, context, localCache) {
  let applyCandidates = new Set()

  // Collect all @apply rules and candidates
  let applies = []
  root.walkAtRules('apply', (rule) => {
    let [candidates] = extractApplyCandidates(rule.params)

    for (let util of candidates) {
      applyCandidates.add(util)
    }

    applies.push(rule)
  })

  // Start the @apply process if we have rules with @apply in them
  if (applies.length === 0) {
    return
  }

  // Fill up some caches!
  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)])

  /**
   * When we have an apply like this:
   *
   * .abc {
   *    @apply hover:font-bold;
   * }
   *
   * What we essentially will do is resolve to this:
   *
   * .abc {
   *    @apply .hover\:font-bold:hover {
   *      font-weight: 500;
   *    }
   * }
   *
   * Notice that the to-be-applied class is `.hover\:font-bold:hover` and that the utility candidate was `hover:font-bold`.
   * What happens in this function is that we prepend a `.` and escape the candidate.
   * This will result in `.hover\:font-bold`
   * Which means that we can replace `.hover\:font-bold` with `.abc` in `.hover\:font-bold:hover` resulting in `.abc:hover`
   *
   * @param {string} selector
   * @param {string} utilitySelectors
   * @param {string} candidate
   */
  function replaceSelector(selector, utilitySelectors, candidate) {
    let selectorList = extractSelectors(selector)
    let utilitySelectorsList = extractSelectors(utilitySelectors)
    let candidateList = extractSelectors(`.${escapeClassName(candidate)}`)
    let candidateClass = candidateList.nodes[0].nodes[0]

    selectorList.each((sel) => {
      /** @type {Set<import('postcss-selector-parser').Selector>} */
      let replaced = new Set()

      utilitySelectorsList.each((utilitySelector) => {
        let hasReplaced = false
        utilitySelector = utilitySelector.clone()

        utilitySelector.walkClasses((node) => {
          if (node.value !== candidateClass.value) {
            return
          }

          // Don't replace multiple instances of the same class
          // This is theoretically correct but only partially
          // We'd need to generate every possible permutation of the replacement
          // For example with `.foo + .foo { … }` and `section { @apply foo; }`
          // We'd need to generate all of these:
          // - `.foo + .foo`
          // - `.foo + section`
          // - `section + .foo`
          // - `section + section`
          if (hasReplaced) {
            return
          }

          // Since you can only `@apply` class names this is sufficient
          // We want to replace the matched class name with the selector the user is using
          // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`
          node.replaceWith(...sel.nodes.map((node) => node.clone()))

          // Record that we did something and we want to use this new selector
          replaced.add(utilitySelector)

          hasReplaced = true
        })
      })

      // Sort tag names before class names (but only sort each group (separated by a combinator)
      // separately and not in total)
      // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`
      for (let sel of replaced) {
        let groups = [[]]
        for (let node of sel.nodes) {
          if (node.type === 'combinator') {
            groups.push(node)
            groups.push([])
          } else {
            let last = groups[groups.length - 1]
            last.push(node)
          }
        }

        sel.nodes = []

        for (let group of groups) {
          if (Array.isArray(group)) {
            group.sort((a, b) => {
              if (a.type === 'tag' && b.type === 'class') {
                return -1
              } else if (a.type === 'class' && b.type === 'tag') {
                return 1
              } else if (a.type === 'class' && b.type === 'pseudo' && b.value.startsWith('::')) {
                return -1
              } else if (a.type === 'pseudo' && a.value.startsWith('::') && b.type === 'class') {
                return 1
              }

              return 0
            })
          }

          sel.nodes = sel.nodes.concat(group)
        }
      }

      sel.replaceWith(...replaced)
    })

    return selectorList.toString()
  }

  let perParentApplies = new Map()

  // Collect all apply candidates and their rules
  for (let apply of applies) {
    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source]

    perParentApplies.set(apply.parent, [candidates, apply.source])

    let [applyCandidates, important] = extractApplyCandidates(apply.params)

    if (apply.parent.type === 'atrule') {
      if (apply.parent.name === 'screen') {
        let screenType = apply.parent.params

        throw apply.error(
          `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates
            .map((c) => `${screenType}:${c}`)
            .join(' ')} instead.`
        )
      }

      throw apply.error(
        `@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`
      )
    }

    for (let applyCandidate of applyCandidates) {
      if ([prefix(context, 'group'), prefix(context, 'peer')].includes(applyCandidate)) {
        // TODO: Link to specific documentation page with error code.
        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`)
      }

      if (!applyClassCache.has(applyCandidate)) {
        throw apply.error(
          `The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`
        )
      }

      let rules = applyClassCache.get(applyCandidate)

      // Verify that we can apply the class
      for (let [, rule] of rules) {
        if (rule.type === 'atrule') {
          continue
        }

        rule.walkRules(() => {
          throw apply.error(
            [
              `The \`${applyCandidate}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,
              'Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:',
              'https://tailwindcss.com/docs/using-with-preprocessors#nesting',
            ].join('\n')
          )
        })
      }

      candidates.push([applyCandidate, important, rules])
    }
  }

  for (let [parent, [candidates, atApplySourcetp"9#LHU&{GGuNNN:3xzўꚛQf񭉮nnd|&B*W_ߎy;z2Gվz0Ӵ!wzTy5^jU{P̻÷[çOp/*~wX1`wU;(۷}n>$i{C׿uoO/;ȣ?NXm셚ѱlL36~/fbXٱ3bKb/-52xs'Uc{_X@[0GGͧ6>23C
￫a~.ߎ0dT腿
-//__17c"?9"D:,Lmssgr^M못՗{GYYlÜ_hjߏڼ>>^T^;%vX,/' .v|i	<SxY=MI"LOJ
?ךO^MRN(ޏ;φYopTz;y:jP=7$D*єhI Ĵ,$f'Lt|Ի||Y@K՝I,ǰ[ϋ͉^D5h牺o$lHFOJIfm5JNO:&I$'%''{[r)ȗ|E%Mџ%2psɗHR'IFSGF2OH}<qHH:.UN"NT%u%_NqNpy'oN֦C*^Lf/H#5x:ǧwJI;6z3j̡#t{1gOM_>?]MmKߔ^פwblJ"lgTuaaTj8_Ea]$8љ̞ljݤ7#S|vh'%?ؾ!R4/sB攭tkW3Ȝud<s2S!D'EOoܖYƓ{fĐOf'J揙73n6m&m6ew˾Q>+۟Lٙ0C?8o/2Cfgwbvwj1T˳ODndlf{Ci,mOeeMϪ` 6l8%sq\>\;sCNgR=RnM]Q'sg澑;7wasYO>rW;r*u_ܖ*ڗe'm|ϩyOj/9o>a{?nˎڕ}ʣϴl{}l;(3g_q+׎ۓ;e<B>`COF=	gxOSOy:99^}y؉%n$0;$P#Q^d!Uv<Y;A`Q;OiKF:*ytg'=:c[s߷5Gn!q{qm. `CcI j:#ss[snkZ#D_:%٭W<vyNyχzUc^|ǼT~WenwW;9%gٶlIK#nm{(wurtk{25SF8¶-v=C_R<<WճQHԃ󏟚!=6&߂p<[*9(wY>mq΀ɣJw9Jak돭D(5s,{R[kTF CK=H\lHJrnm〰9t9rJNNPBv@ny?h\7FnF51S67163=]/.hE/+h+DirJ'	Õ؅#bq=}{){v9?Tj~_~6qG=_~pCdW{SVoBowe&kΤ|BgogM-.*\Of܀lپ	AIN<B]oM߰rm!vǟ6326Y!FНx~狵:;+o}G/m|c{.xh;ևD/9B},!yWG;0]j!֙'LS%.G-NoA %)2n%-L>׏a`9HATjw/ yn?кxY}-M'qj_0{U1G|~E!h;sq	PG-Z'sh&ち?nwc(W/wwϩH,!dB'MHs8{glN/؂>a)[~v,Ukϯj2I9/jSw̯[I]֒rȢ6+N
Cs5%ħ;$Rޠm߲L鴟fz5dy=2bmV;rٶ,-V4SOiPdvqY9nC4ZjKdzlXZ07,|4O}@.b;no;BqKj+5&Lͽz$Rk:۽tLF3TۿMҸݳJfWUb>
.Q4WƎůƿ(^BK5R3=Y2?16hi^N(}h'Z%߳aE]<yq>k^χ,LXuO&_i͡7_{Dc3)>ϕKP`JbmI;g!.Fv[rK#lfY^>%9}ޯdM~K'kz{v7o5%{6>=]ofݵv6Lwt7x7Cmyvﷴu	j~2?ˍ,G88uۖdV7gnrC:qꥤj@0=fA8ijmǎSC/Vpzr))Xk~VJdzPK%P;#YLI|z)]r2;K/$`OL|(ӹG[sz=|*ʕⓠevE?W:Z9OqJyt3'G7<mAׅ1AT={a -9kkٵn<lQ،Jzy?gs>GqEz_rI/KvIt/BM[!3{&~W4|Nw=Zy9irue)munc38ywsHmfƼ.{lR^	4pڵ|GmR2^½j{.ٖP8oeM)m$ýȧNzI]gOKJQe4^fv_v.il,G;|)T3XgQ[T<zMbffp^/hq""Q*H˳FqK0>a E|f54{JnLh#v}j"K7΢|Q <sƅA	l3ɠ~FaC?կa:'ri{"}$0~5c{C/Ya2g^*8ѯ2MW_n,<F94E_IԊ!06| o#3.8B׌֮-SG$/d}>K+}NGo]K᮰91w;UZJN}Ÿ'1_iY2Y].MB>]Z羝FRd'>H>-}MwG?|ZSꀬn,yMEӱQ6{Y@~AR}4lkڬvo0}O~?=py^][Rj}S⸢VPog~iߙ}*; :E9VmcHc۽1>k#eE3*ϡy#3JX+Z؛"+˅}~Dw3uռ?bBY>Oi8td(g[e={>{Nlկo719"}$FӼ7FW8Ev;wآ&"8We8;͞rK럻JIޕw:/D:|1%-+CV./}DVᒫ4"a%fv)ai[)^^sctS{8'R]<hH۔iv/ۮit;}HKի۳@\R8ǮBinQ;#c	Uk=q`QL?o|K<QQZU4-;MI{]ָk/y%U'=ϠWG*Y}ꭑ[Kzw{N~II JGýؓA)TlzMFwsq8kgήHԙ&Ӿi7AyN{ǃoߧIb#NIm3;{Z-bsstzޭoRN|BsFgɽUUQb0UBrrvٮa+HˬۂkGgrը)Tb٩NiU_'/dOK|a/Ys?VJ~[4z:Z]WBFQj`{R[~׵vz&YF:Տʱ~8;{.8Rx9p)mᓔrvE󬅳Oo$]Zfg;UC1Cy)-wr:=
M'l{1U	ah}EIPOGo)Gk+Y]:SSoSߪ_ĳG,.vHJ<ȷKTnB7vPvS )-G)C9e~b_6gss{{bEn.[9zu%P3tX5{".W_X6*cCk1|iQ5r-0Wcm8o7d _NkK_,Hy^ϝz~a#~KWt]/=P(=~[$,w6Ə}=jWov#Sb=ggP.Oڈy:گX_1پ.jU$flkR#6cɺG%Ω\;}S O]ƵH|q5X3HĨqիR{իӷ]bXA:ywz# CKwx ̞;;S4AsA"\@A& J\&
ґ&%`E@DEAA@+rA*;g'Y4{{9}lMᏍ5{H~?hocig>>>>۾}}}}?ٯ8ëix]#xG<Ǉ/IL|>߈O_`7%*ՉZD>iN\)|Ϗ5;gt8ǝڎ;9ptwrwuXupulrpurspq4ʀJ4 M*ʭ@< -h/h8b)uʊDITDM#_c`&~.Xz3Z[M`B	RoPe&yiS ӧ2SS[z][mD?,b13]ܽZRHS=͚j1^TP/gշԻ+/PH-b9*YL#Yb_q8\lL"N%rqA.oœixTS(eKbs-)K/URu	Sܼ[u+rs?ZS3]Om܃'3q9%Ŕ M*T%pYQ&ު=FuT{OרiRLw3_hkK܍$&I<$%Hϓ/H(Uui4̗5!z:yM!)e #vHkM/(o,5K= vmtNiuK#5e	FVwD9~2}+s@m-֖js5=}i5-_<=Eaz0-0ke}9M\3_3)w=,)h9y9dؓ.'t~~*o
.ͥ
	r{-^=9Ë15'Wܟt"q#'wݧ$&'BکG?FCded*ݽ8[bTF*dZyX)L}Uݥ:zwߴ: C χvDToj6א<6$MP'OTWnHiifw3eQB~&HXėsuL1S</͓ynKf,s;v~2UdQu")d%]+;U_Aɼ)\o(=KO?f7;˰-oDuv>|}]z@h*_S\@ϻxWg;