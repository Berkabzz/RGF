/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import { StringDecoder } from 'string_decoder';
/**
 * Same as StringDecoder, but exposing the `lastNeed` flag on the type
 */
type SD = StringDecoder & {
    lastNeed: boolean;
};
export type { SD, Pipe, PipeProxyErrors };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
export declare const isStream: (s: any) => s is NodeJS.WriteStream | NodeJS.ReadStream | Minipass<any, any, any> | (NodeJS.ReadStream & {
    fd: number;
}) | (EventEmitter & {
    pause(): any;
    resume(): any;
    pipe(...destArgs: any[]): any;
}) | (NodeJS.WriteStream & {
    fd: number;
}) | (EventEmitter & {
    end(): any;
    write(chunk: any, ...args: any[]): any;
});
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
export declare const isReadable: (s: any) => s is Minipass.Readable;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
export declare const isWritable: (s: any) => s is Minipass.Readable;
declare const EOF: unique symbol;
declare const MAYBE_EMIT_END: unique symbol;
declare const EMITTED_END: unique symbol;
declare const EMITTING_END: unique symbol;
declare const EMITTED_ERROR: unique symbol;
declare const CLOSED: unique symbol;
declare const READ: unique symbol;
declare const FLUSH: unique symbol;
declare const FLUSHCHUNK: unique symbol;
declare const ENCODING: unique symbol;
declare const DECODER: unique symbol;
declare const FLOWING: unique symbol;
declare const PAUSED: unique symbol;
declare const RESUME: unique symbol;
declare const BUFFER: unique symbol;
declare const PIPES: unique symbol;
declare const BUFFERLENGTH: unique symbol;
declare const BUFFERPUSH: unique symbol;
declare const BUFFERSHIFT: unique symbol;
declare const OBJECTMODE: unique symbol;
declare const DESTROYED: unique symbol;
declare const ERROR: unique symbol;
declare const EMITDATA: unique symbol;
declare const EMITEND: unique symbol;
declare const EMITEND2: unique symbol;
declare const ASYNC: unique symbol;
declare const ABORT: unique symbol;
declare const ABORTED: unique symbol;
declare const SIGNAL: unique symbol;
declare const DATALISTENERS: unique symbol;
declare const DISCARDED: unique symbol;
/**
 * Options that may be passed to stream.pipe()
 */
export interface PipeOptions {
    /**
     * end the destination stream when the source stream ends
     */
    end?: boolean;
    /**
     * proxy errors from the source stream to the destination stream
     */
    proxyErrors?: boolean;
}
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
declare class Pipe<T extends unknown> {
    src: Minipass<T>;
    dest: Minipass<any, T>;
    opts: PipeOptions;
    ondrain: () => any;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
    unpipe(): void;
    proxyErrors(_er: any): void;
    end(): void;
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
declare class PipeProxyErrors<T> extends Pipe<T> {
    unpipe(): void;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
}
export declare namespace Minipass {
    /**
     * Encoding used to create a stream that outputs strings rather than
     * Buffer objects.
     */
    export type Encoding = BufferEncoding | 'buffer' | null;
    /**
     * Any stream that Minipass can pipe into
     */
    export type Writable = Minipass<any, any, any> | NodeJS.WriteStream | (NodeJS.WriteStream & {
        fd: number;
    }) | (EventEmitter & {
        end(): any;
        write(chunk: any, ...args: any[]): any;
    });
    /**
     * Any stream that can be read from
     */
    export type Readable = Minipass<any, any, any> | NodeJS.ReadStream | (NodeJS.ReadStream & {
        fd: number;
    }) | (EventEmitter & {
        pause(): any;
        resume(): any;
        pipe(...destArgs: any[]): any;
    });
    /**
     * Utility type that can be iterated sync or async
     */
    export type DualIterable<T> = Iterable<T> & AsyncIterable<T>;
    type EventArguments = Record<string | symbol, unknown[]>;
    /**
     * The listing of events that a Minipass class can emit.
     * Extend this when extending the Minipass class, and pass as
     * the third template argument.  The key is the name of the event,
     * and the value is the argument list.
     *
     * Any undeclared events will still be allowed, but the handler will get
     * arguments as `unknown[]`.
     */
    export interface Events<RType extends any = Buffer> extends EventArguments {
        readable: [];
        data: [chunk: RType];
        error: [er: unknown];
        abort: [reason: unknown];
        drain: [];
        resume: [];
        end: [];
        finish: [];
        prefinish: [];
        close: [];
        [DESTROYED]: [er?: unknown];
        [ERROR]: [er: unknown];
    }
    /**
     * String or buffer-like data that can be joined and sliced
     */
    export type ContiguousData = Buffer | ArrayBufferLike | ArrayBufferView | string;
    export type BufferOrString = Buffer | string;
    /**
     * Options passed to the Minipass constructor.
     */
    export type SharedOptions = {
        /**
         * Defer all data emission and other events until the end of the
         * current tick, similar to Node core streams
         */
        async?: boolean;
        /**
         * A signal which will abort the stream
         */
        signal?: AbortSignal;
        /**
         * Output string encoding. Set to `null` or `'buffer'` (or omit) to
         * emit Buffer objects rather than strings.
         *
         * Conflicts with `objectMode`
         */
        encoding?: BufferEncoding | null | 'buffer';
        /**
         * Output data exactly as it was written, supporting non-buffer/string
         * data (such as arbitrary objects, falsey values, etc.)
         *
         * Conflicts with `encoding`
         */
        objectMode?: boolean;
    };
    /**
     * Options for a string encoded output
     */
    export type EncodingOptions = SharedOptions & {
        encoding: BufferEncoding;
        objectMode?: false;
    };
    /**
     * Options for contiguous data buffer output
     */
    export type BufferOptions = SharedOptions & {
        encoding?: null | 'buffer';
        objectMode?: false;
    };
    /**
     * Options for objectMode arbitrary output
     */
    export type ObjectModeOptions = SharedOptions & {
        objectMode: true;
        encoding?: null;
    };
    /**
     * Utility type to determine allowed options based on read type
     */
    export type Options<T> = T extends string ? EncodingOptions | ObjectModeOptions : T extends Buffer ? BufferOptions | ObjectModeOptions : SharedOptions;
    export {};
}
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
export declare class Minipass<RType extends unknown = Buffer, WType extends unknown = RType extends Minipass.BufferOrString ? Minipass.ContiguousData : RType, Events extends Minipass.Events<RType> = Minipass.Events<RType>> extends EventEmitter implements Minipass.DualIterable<RType> {
    [FLOWING]: boolean;
    [PAUSED]: boolean;
    [PIPES]: Pipe<RType>[];
    [BUFFER]: RType[];
    [OBJECTMODE]: boolean;
    [ENCODING]: BufferEncoding | null;
    [ASYNC]: boolean;
    [DECODER]: SD | null;
    [EOF]: boolean;
    [EMITTED_END]: boolean;
    [EMITTING_END]: boolean;
    [CLOSED]: boolean;
    [EMITTED_ERROR]: unknown;
    [BUFFERLENGTH]: number;
    [DESTROYED]: boolean;
    [SIGNAL]?: AbortSignal;
    [ABORTED]: boolean;
    [DATALISTENERS]: number;
    [DISCARDED]: boolean;
    /**
     * true if the stream can be written
     */
    writable: boolean;
    /**
     * true if the stream can be read
     */
    readable: boolean;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args: RType extends Buffer ? [] | [Minipass.Options<RType>] : [Minipass.Options<RType>]);
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength(): number;
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding(): BufferEncoding | null;
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc: BufferEncoding | null);
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc: Minipass.Encoding): void;
    /**
     * True if this is an objectMode stream
     */
    get objectMode(): boolean;
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om: boolean);
    /**
     * true if this is an async stream
     */
    get ['async'](): boolean;
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a: boolean);
    [ABORT](): void;
    /**
     * True if the stream has been aborted.
     */
    get aborted(): boolean;
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_: boolean);
    /**
     * Write data into the stream
     *
     * If the chunk written is a string, and encoding is not specified, then
     * `utf8` will be assumed. If the stream encoding matches the encoding of
     * a written string, and the state of the string decoder allows it, then
     * the string will be passed through to either the output or the internal
     * buffer without any processing. Otherwise, it will be turned into a
     * Buffer object for processing into the desired encoding.
     *
     * If provided, `cb` function is called immediately before return for
     * sync streams, or on next tick for async streams, because for this
     * base class, a chunk is considered "processed" once it is accepted
     * and either emitted or buffered. That is, the callback does not indicate
     * that the chunk has been eventually emitted, though of course child
     * classes can override this function to do whatever processing is required
     * and call `super.write(...)` only once processing is completed.
     */
    write(chunk: WType, cb?: () => void): boolean;
    write(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): boolean;
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n?: number | null): RType | null;
    [READ](n: number | null, chunk: RType): RType;
    /**
     * End the stream, optionally providing a final write.
     *
     * See {@link Minipass#write} for argument descriptions
     */
    end(cb?: () => void): this;
    end(chunk: WType, cb?: () => void): this;
    end(chunk: WType, encoding?: Minipass.Encoding, cbÙ²…˜Èd/‰B—”E±Ùà]ïyŞÒÜÅ“¹ˆƒ–PıÄº§½Ìù
[çcà‰ñ§z<u},Xj¢Üˆ!Ìø€èòR\l,‹ ÀoŞû‘Ú€ª¢Ã±á®³ùİğ#Ú±(c°va·±
}5nÆ}~Tå.+*^X&¤bÏø„û;oÀ´L½’² 	Eº6a[©¡X¶wÙ.‹†¸ãÌî!âñºñRõW†YY *ÇŒ\']Ç«pÉÿ?ÉKİK¬ş8´}³„Ã€Që#Ï²­I±nršÀ“‹£×ášÅşNQ_-‰SMgı(¾&Ø“\N³|òÁóÜë±Å„=º.ÙG…·ğ ÀVñeìZ7Õİ'¸Ö<B6èìšÒv®»Í’âqL³÷~×xï7œ5zá»”•B„·8=¾ ¨#‹öİ4äÎ#9òUË^«*„.M¾k/ÿÛ›Y¯b)¦{'Ï8.T€öé4t³2cÕ"¼™*¦lØ¸€¤–İÆ1"•ùùV<FÑÌ¦Y”õe¬ZÓ-=ò‰XÔÆ?jÑõËÒànu”º–“î]ü–Ç¸‘µËpŸÎviîˆÌ{9$1<VWN—»ÃÑ7ß:}ÎÒÅ·nÙ–ëh\Ndì	Ÿ˜ÈÖ°ÕªÑå İŒëĞw0¹ü&ØÄT@’4‡!É¡_Óo­)VÃM&É,{½<Ï¦ _4ÜAàq5¸ë­Ö&Ò»ÇéE=€ÑöÓ|UV¤·^Óµ¡x‰…Wf‘nåğ99ĞîÃôÊÍ°™w!Wx=Ó0¥Ü—©Ai/ªjõ6Å€í=³W¿Sá…ú%ÕJVã|¦]óÃ»3PEª›İ–n4)~<„cÔœéÂõ¹`Öæ¥ŸD7¹]¥‘ç¬c`àİ‰2•,0W££LZC¡¢òMA•Ï(øø+Û±„'*ãåùlÅ¾<fUdiÉ2¤¤ÿÀˆ3ÀöôŠ}ı³5‰2EYÓ‰:+ÔXØØkÖO{-İ¹®	Õä(—r|ê†`Zï–Ô‡ J¥"µ£¯ÑèBBYTÏ/kãàìzæV{FÙtÖ€9¢!!EâEÚQ¤ÎxYëÃGÇùÌpÃ{áPîrÚhí,s¬w7/e¬\P!–ÇNI¥’‘Ú	y@×1%§İ9WßK¯úÕ_#›[¿é¬`	•5O#šùUêóóVù;¦Eb†!6ÿšxÍ¸â¾ŸĞ2 g³/|m‹Ö>µ¤Pö#âW"¾}k_ÏFáÖµô¢#	›è-¤÷~î@I¯c.æ½ôÄß§˜í…&Z‘ÖB¢¨¤;×Áñ~O3¢Qxöß½‰wã­s\*ªGâkhŸJâ9?*HèİVe›-îIJK+ÛîÍ	†c“2àıµ¶¬ä™>ø\‡LHÀŸEìøfÎjËnJşùn BÎò©`µ@[c¯;cô¼ÂtÛ’De>(½e›ËÒa£!føQ¿ÒlÁJœ}i…?ºĞŒ:¯×Ú•4ÄÛYÛ¨bo1˜=Í´.YsŸ¹3BséÈM×J’ÃhUUªÀ%øÃqÕÈpğpyq¬ëCa6cJH©£•Ï„üÇÈòÇ7"
Ìm!S·óŞŒ³¿VÕåZ²—G³ù|6[b0Ğşeüª.;ÓçÉ.¾rÓ Nìgû-“ß¸TìÕ»%:æX±áhû» 6Jjâ@Ã¾*AO•¹ (.¿.Í£nôµ2Ìã–7fÇo¶}ëùº‹¢µi¬ºÇÆn	=‘usê"“Aúe	#OÃH$‚ŸíÑ=ùƒQ%ÿŸa×ÚÏä0È…ér=âêÀÿåWµ‡h¦Gß`³òşN¾Îğ‚ˆï‚_%D{é†™&"Å¦!Y=; Ü±hÊ¿Ö%®(²Še%
M9y‘Ú›„“<¯1ë>@úzQ‡ŒÒDÉ>ª{¯ÿº¯BÁ—`ámmÓ™ªN™Ê>íKSÖ]g45‘íj°õ§=~/o;Z±SÌgtŞ’jn/Ô)O¾ù^]ßO˜ ”õ^OÜ+‰ş<ü7†&g
´aÈO@ ‡.aÑñ†9Nç>ƒİÙeœdô`$Ö(×) Íä%®s4úÊJ§ /²á9å„Pv}t½à—K#şŸ‚,=Ñb2Ll¿?õ.F‹e¯¶äzBìLĞ¡²€ô»vÆ¬³°/ï¶n]½Få—•à²=£¿ô“ÿzCÃ	™ô¾‡Ö¤İ»móC3I*Qßâï—­Bÿz/ä3%¦¶xtÈ¾Ş+eË#iæ¼'Õ#Ò];ô®önÛ&Ï	‘ÇJfÿõ÷uQ!ø×fÈEnpqîe-Ù„ó¸J_OÒœôhîàŸº§+£‘î{} u®Û÷ØÇ•í$¦Ë²i3Ø_h‰àÒÃöJ/uHì±Ú
pzE¢@H¿ò>^¼#û›ÒÆ®êÍoöŞ•ïN	ø©Ã«¿2!+{­cNôëQ3Sà?3¨î~ÍZ‰T*Ã÷O>¯ÂÙ£ÓZ»%¼§ñH7
Œ8BAOÛµBÇšyø>2\÷Á@eÂ9²Á^JöÈ†p³ç?Í’„˜â–\ƒ:9W£ß›½ã‚Ëí €ö:Ğ¦ïS7:^†P€"o?´çS9áØ5>Ïı¦¢	©«·’´ØŠÄÏ2¤ª†®9ã?ëírÙ+Ô¨ò¿Œ!¥²DªßuÂÉYŠfÂ®$Ñ;@m<˜"JìL$Qi˜\±¾ø+’Djpìå¹&(Áz@ ÑNHĞ!»’#ûiÿ ó“ eô3×˜»"•Tdõ:x„jÙ¤Îfpr‡Ü·ª’èÆêjİ@?¬|>çÓşõE5³ÛÖ•Z¤\¥Aj“ì°À`‚š[ú ^qJ*V¤N.íTXi
åËTeC¸œy‰oÆøƒâp6¿ljqNX`z=ù/³íMı¼ınhOëßqtÜ’l°‘{ş›Äˆ#ééM¸©B#Â¨…F/	’o¥İº;›¿&‚ùö4KNp”-£ë|kY“ûwÇ›"g^?ú»‰ùÇƒ/ş)•çÚnqAy3¸ Œïé{„ğ|4W› h{hZ#kìbg'6Ã	gş[Fz‰¹¡ìE^§^
xF¬Ü–0_>ádB1]n¤ï9ß>`·sğô3n“ëMëšçŠâ¸ö„Z_EMFÄ“3[¡l©»:ÙÊÇ”Au¯Á
Ğx°}ñ$[ë“ÅUU_usV@X\äØÊŠœ°Fè]ØD“3úrqC(¸üTHò«éÇà/qĞî®çWÓxƒ³ÀS¯såu)º^ïğWïTMú\ª½[şT%>¢!ê6)—èù0Óg3~ñÌuç‰\ ‹eFÕœxèºşÌ†¼nDJÿW;×Z`7””4Rh[TdfLáîjõ¯…&ÓcêÍ[Ãu'zŞ‚ÁwÖRÒ¬ÈÅŸx"‹k78ç†b¢úêò­6Šô-m«£°GXéAXçD¥-!æ+>…âùq3Õø³²à(Œ¡]Láp<ß† ß"B<•ÑÑwÜè¤)÷Á‘9,¼Õ£Ç_)¤ƒ÷õ}° g~`¥Aœa<éU‹[´I×eM¬ÊQ-Fk”vàŒ³:ï©+&$ Å’€ÎÌ.Ä
Ö,'GÂìöp¹Fê€µ?Ñ8ƒrÑ»|êœ³8®"Ißx‰¯ê8}”ş×¨øq$AÛàæÆÛ›|ÑœyĞ´&:ôˆÁå6³úµ“Oƒh[XD×Ë§ê§'n~ĞÜ¬Éh¯±OÎDÀ[‰…w«s ús+lÉ›%Ø[bˆÊ„€fI€ìŒ¥Ø)ã¨şøvD¡»#Hl$G{0^_PGq»Z—êHå²™«/ñB§¾éÀ0/Øû¢—Wh9b¥ònû,»Å’Êiÿùİ=¸nè•A{„©ËŞr2òE£=åFˆÜ	AågŒŒî±vFìOB!|±·9Y›îØ½ì\saİ¿wÌ"“Sğ¨y†º˜KõU]`š'&Êq?(Vûvón)*í°±Uovût~šø§Q=oU|Æş ï¯)?ÄíË¡Ó÷oı­ĞPeZ¡†Ëlcuşş4–YF¿…ÙŸCn9˜d‹ıFYï±xj&ô›Ëä‰mæb3`Å³çŞŞÜÜ·6¬fŸç8~ï<(0éóx:s©;±M®Ò÷\*’s<‘{¿³ô…&¢Sn’ßš`¿4Œi6Œ›q @ìÊŸ·D°j.|‹j]„éîËà‚ç»´k	
m’òò±¥ü›Şûí1†çË!†Ô×}	ÌuóŒ
‘8ÚC×!Òè‡…ÈÊêÕïMÛÛ÷
•’ª“"Ìƒ¾üANŒÍùÕôKñÊŒj‡•}ñĞ/2§t%öà’9£	ÇcssÁÍ0ÊìYhöo’nüKúâ#@Nâ*º$<¹İµú.ƒpÊ:=Êz4X¦¦½ë¹!õLæº¤ûfÓ¤JTV¾{ù–ıáÕ:.ò®|â$ëx…ôû*pAo2Øf^ì¬Â·»…öñÙ<–Á©àfqã£ûŒä¬äé"w³ïp,İ†¤Xd0ëJÊöKü1ÍnöÔ.nõÀEÑÔO¬gÀ˜FÁ`¦™ë?¬+S¯¼ë?Sœö®'o«Àë) ÂhQJâæR³§½ï2"wİZJeÖ©#ƒ¹%Qş²öã2	©ˆyç®ŒÊñ™YCcF-¨{ÖC­³.§N­0Ç?Pö_A¿vòÓ÷{¢Á_Xäa ˆN£?7Lî³xmj8—í"ÍÙÏÑ' ãE×t.Ñq\æSd°À‘¹ËšŠŠÉ¦£û0ºÁ‰±=D%€—'*õSœ_Éêk¹mSáôÿº!9MíZë5‹¥\ñ6Âé¾v`ÛH"ö½+6SŞSî©èz–¿„h×+3„n›mˆiÀûÈß6À¤Rl; İ31Ÿ‰Ï\Ã$`ûê·nÕ6kĞ‰ä~CVğ\"úÌ”waƒİ˜f`z|-‡²ä‚?¡^^%Z)%zÅã^l\7[Gæª‡šCZê] 2j¿ø5Ø7Ÿ<ÙOV˜2œ ñFxªš9Óæé
)Ó(a‡¼¶ÇÃ–oa:â~e‹’è ¡Ã•¥ûCÜ´yãA
;äÒvÚ›:Çÿ-^©¿Ä¦~]PÎ"¼.V–¬ÔÕD )ûpòùõ€±ˆâªÊÄÌ‘d*+oó]XÒr(µ•”áxGÓYüPw¯Öá³†uà@sœİ—rÃÇS“_TÛ ~va¸l÷µªt„ ÿ?w#ì2J5&€Ğ)ó¯L?õ›"Ù£uu>¤ÆRˆÊ †¼á×ñ33mä÷m<‰lQÊMŒ\bXk<›\”g‹=èËïëã%û/+é—ªÑ´fM¸ì<TÇu®PˆîFÆD
ˆkt“ÑH2!,/¸Ê9ò^æëäWÏ4êb…Tò—Å)1›2CßáÕ_ŞÇjí‰oñ~«÷â,bıWF@İğï%¼]8üÁÂša+…Œ.Õ€]İë:%h¾±NÔ¥ÂÅ]ÓÔí8G
ò„¹s,o¥8¦¸·Vı·ÙÄ—\Æ*j/Œşäğ›TkmŠ¬À™ËY_Áy‡£ ‚&ƒ
nv‹ecÿA’0'L±ÜZ'îº^ZËa`&¡âpÊ8Ãû‡ˆ½‡_ú’C“Ävâ	aXh<22T„<f\YÀªÛH±iÑB3º¯ŸøçàDüÊàÂGó.Šé gî­På=ş}¯:øa581Ûi)ÂËÑù‚1ğp?ìÄ;U–]ÎúP7&ZD‘Ë´dµÑòJ!{’ŸAtaİm=¤2Qç“#‚ø(ÚKò¬QïşıÙç÷¹ƒ8‹©äæï|]¶*eY%İ>.³Q&¦ÇáÍX¨±j‘Ä¸¸‹dO“uÍwÀßBr…!Ğ›Ñ)½¾xşy’Å½xHğÀ"öAzgÀ(„pœÀØá‰›ğ³ˆÎ±ÏGi®o–]Šp„Û…¹ Ç0Y#ág ô›ĞâÒ	ñâƒ¢^ƒÌ“­‚®E@A›d#B>äâÃı§Ä®9guîX2#/ T¢púöå1Øª:Ği6úuû½PU.µ”áRã‚‡ÁilljQ;[ÓY™ÿN.cˆUlu¿å½ËÃ%Á.lvá’EKdŞ³7óI_ï¼kæyQ3‚Z[ÖW'Zsá’q
S-eˆ¦Äó
ŞÕ¦yt®+Cª>“(’j*:AšÀ%V‹ôÕ¢P,.L€E¡÷| ±ö*ßÎ´P…ßyPOçx >q³ı†ÄÃ3MF¸$.ÿN³Şğ•À-ïWì–¸›66¦¥Ë’'g´+3?®Ê)Ó‚Ï,R¹¾L5ZÚnŞNk¼$VyúR<’ıƒo_Aùïpp©üwd k<u»[D›;õîLò`áä·ÄÒ	Sœ™ØŠ4*M3ÅhF{÷LY•â¿BE·Êv„å*Œ^ºQ	 F¹;’B8 u¼tXq;â,“cÊzÓÕe/…zôÊ´£—ò¦íŸH‘§Ê _¯­Q÷âD‡>¦ÂÂì&ì_ŒœzÂ¶íâ4•$–Ñ£c\GÈı£gš1yq˜EĞõ`${ÑOäÅÎ\JÕ@Øüy·×¶Á¨%åK&»’'FQ'³MVbÓ•k3}ÈÍl>ÒG~øèZìÖ9î9`:Í®;ÆBgUmÀ¬DÖ«6È?şì¬ÚÛWÎ
x5?Y¦>'f,¹i_8õAÏ†KÙ6
	bà+I`Ù_J£dnß}m(÷9¦“à£¦oxl¾vb(ó†„=¼PQÈÖ†ux 8/ı’&MAmĞ¯u³9wÇ‹,Ä…ˆƒ0qú²êÎYœ’õ`“İedõkIçb7iêêTÌšõÉÔ0itv¿mÉìQdIãïˆ¾„‘Vúô2¹P½ÒÎœÂ?İ®‰¾ŸİË[I²âsQ‚^éyøŠ
nKÔñ;yºÕØÊŒËÂÒ¼W2Í5ÌŞÈõæúóØpR'4u?ìˆ³sÄeÓªÄyñk‘ş"] ÿ†g5¿¬#=>›Ldœ“Ô‡š	D<[t	1a•‚‰~jö·ÌœSÑó—Yæ0›‹ô²=Ğ2DÇƒ"Aí*úÎğ¿¿„jLËD¥ãÏ/Öo!ø\ÊĞq¢hø_¬±>ôÇÇINÇÕÎkåÌ¾;Äãj‘mygøa{.2ùbäÊ)R¥§/†Ø¾AâÚ7á ìØCjqaH ßàüš1Ü[Xñ¤üôk:wı¼ı.Íø1Ø$ıInÂ¦Y,3ñˆx±0Ù{ì)bEPJ~€³;ËI9œ¨oşÏ>ãli×³½­cì¹¯}¼ÚÿÑbŒ?ÒŸx"ÒpJ	Å‚) ‰6×.ªÓ¹ÂØ:øNÒ_ÇUëm
Ô¨::˜‹L±è6NJ÷O}´œ@\÷ñdSÿ×mZï'¾A§K>&"äsD9Û¶¥Ï@-–ö{ /4Ê€6õ¤Dâ"O¬¼“´Ä­nÚ¡	ªUÍ‰Rì²ÃÅ|!ˆ9pç*e\’ÊÎ sŒ8q?P‰óÍ4ô‰Êß.ãd€£µ°S?û_ág&0+ˆÅ	·›Xšl¾e,XIs¼"ó"áÅî:;lÒk!ÆHì
Ä¼‡+1‡Ëª…â‰SLQŸKà£æ¸I9wô~ymß-ğíãÍRE3+uU¬ú')—:üÇøÿ¾æNĞkÁû¹gÇŒïI…,Š-µt xuA…wyJgıÓCÅøCÒ¨ÀteMB	.øÊ6P`ÿ¶où±.½¥ìŒ#…|Ì>:2ä¸ÜIA@,n×OAÔfQ-˜sòQl:D[lé§äo=ÒpÜJZèÄ%kZDc­ñ'IÈKıú$1*RŸšnİªn5ÕG±vúİÎ°o  yï®9b„İı*„4«[3˜Š+˜‰½æeôğ©I˜ıpåkZ}7nğSÛ§&áû1ÔÅ•œÿ­`C=ZâHÏ¹ˆÖrïje‰¡„]ı¤²è}jÓî¡3ïÈ¢é	4ŸEEÛ_7aÎ}Ü9 çÎî‰4J)ÆzŠ¼ßZ¨¬dµÉr²µCÕ¢,EÎaÓ\=§ó„íæ‡d¹º9¦SÖnåT4¾ûËqµ4ÂPZoXOQùHU¨8”w¾^3²VJ |íMèì€ŞÉËÆ1å6lC+m°¥tÙY†Ã«÷ªI¥8ÒÀêÆxèš×?‚—°æ±s[·ƒÔÜèXüíª=Ä.Õ#,_¬VŞç†s'£F‘7,€õgîÅ»":éÄ•é‰dË¥’Ö¸á2kş–ş€û(Jp#ˆ1ÿ ±ƒŸÆÃÜ{µ›Òİı.oÇ:¬Ğ˜ƒ¯ü4ş	Ûuôº- ¶­—,v6EFr£Å@Õã¼·ª'¬]Lc.DÂ»½–mÏ:¡>Ü#ÆüŸaúı¾)—¸Ï1ö›?ª—Şì‚”{ùÿSzİ·İ|7Ø 8–KÄÌòs
¯¶·¿Uíó´Tyøt=ÅP'W¦4ñ]U´…m‚ª¨!£F×\ã.Ú¼\z¡Êœ-2m¯.­µ†Í”ŒD‰úã$ñ™ûï9"xíôşAÇË¥²5T¦ô~x´Û»j4Î®’Ù"Úù»ê›şœD‡Ã×Ø»#×ş÷œğ_&]…\îúƒñ¬wãÂ}x÷¨è‰ÓqÊ6òÿÊ9ÜÂË*¡ùI„E+¹aòŒk¤»Nß–ŒöéPvõ;	º£õñ“ı»Cq÷{4ÀêMN%¬ÉK¼?q éÅ¹Å€Cutÿ0Ÿh a¥nĞ<ÆÅmg›n¥!êGA!´)âhâ‘*+O¼=ºÀô|£…HNBÜueaÅb*«hûê o 7ÄaÿVVõb$šÆ“…mXó™ç~ëgVmGm·D=b·¦"Ä&ÛŠĞúr­6–r<J3MÜ0˜pÁv–—>ÛömıõßY¯?ŠærV6¸¾Æ¥,ë‹Û³i\<UÅ4r	É„BµÌâ;G¸^µ$Syd‚nËSv“Ø!”“‰ä‘ôÂïï£ÄòRv‰À¥Ì4Ğš™Ñ9¨UÅM] Ü½CÚ¡&©oğÜX¿û62ÿæ„½"V¾ü!¤SJVo8ïü´MÓ¬.7à€b%î}å“`Ô@™áv€X>í7êRïıá0Ş'³±íMÂ=Ë…&‰q(å®×B