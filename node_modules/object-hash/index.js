'use strict';

var crypto = require('crypto');

/**
 * Exported function
 *
 * Options:
 *
 *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
 *  - `excludeValues` {true|*false} hash object keys, values ignored
 *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
 *  - `ignoreUnknown` {true|*false} ignore unknown object types
 *  - `replacer` optional function that replaces values before hashing
 *  - `respectFunctionProperties` {*true|false} consider function properties when hashing
 *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing
 *  - `respectType` {*true|false} Respect special properties (prototype, constructor)
 *    when hashing to distinguish between types
 *  - `unorderedArrays` {true|*false} Sort all arrays before hashing
 *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing
 *  * = default
 *
 * @param {object} object value to hash
 * @param {object} options hashing options
 * @return {string} hash value
 * @api public
 */
exports = module.exports = objectHash;

function objectHash(object, options){
  options = applyDefaults(object, options);

  return hash(object, options);
}

/**
 * Exported sugar methods
 *
 * @param {object} object value to hash
 * @return {string} hash value
 * @api public
 */
exports.sha1 = function(object){
  return objectHash(object);
};
exports.keys = function(object){
  return objectHash(object, {excludeValues: true, algorithm: 'sha1', encoding: 'hex'});
};
exports.MD5 = function(object){
  return objectHash(object, {algorithm: 'md5', encoding: 'hex'});
};
exports.keysMD5 = function(object){
  return objectHash(object, {algorithm: 'md5', encoding: 'hex', excludeValues: true});
};

// Internals
var hashes = crypto.getHashes ? crypto.getHashes().slice() : ['sha1', 'md5'];
hashes.push('passthrough');
var encodings = ['buffer', 'hex', 'binary', 'base64'];

function applyDefaults(object, sourceOptions){
  sourceOptions = sourceOptions || {};

  // create a copy rather than mutating
  var options = {};
  options.algorithm = sourceOptions.algorithm || 'sha1';
  options.encoding = sourceOptions.encoding || 'hex';
  options.excludeValues = sourceOptions.excludeValues ? true : false;
  options.algorithm = options.algorithm.toLowerCase();
  options.encoding = options.encoding.toLowerCase();
  options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false
  options.respectType = sourceOptions.respectType === false ? false : true; // default to true
  options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
  options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
  options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false
  options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false
  options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true
  options.replacer = sourceOptions.replacer || undefined;
  options.excludeKeys = sourceOptions.excludeKeys || undefined;

  if(typeof object === 'undefined') {
    throw new Error('Object argument required.');
  }

  // if there is a case-insensitive match in the hashes list, accept it
  // (i.e. SHA256 for sha256)
  for (var i = 0; i < hashes.length; ++i) {
    if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
      options.algorithm = hashes[i];
    }
  }

  if(hashes.indexOf(options.algorithm) === -1){
    throw new Error('Algorithm "' + options.algorithm + '"  not supported. ' +
      'supported values: ' + hashes.join(', '));
  }

  if(encodings.indexOf(options.encoding) === -1 &&
     options.algorithm !== 'passthrough'){
    throw new Error('Encoding "' + options.encoding + '"  not supported. ' +
      'supported values: ' + encodings.join(', '));
  }

  return options;
}

/** Check if the given function is a native function */
function isNativeFunction(f) {
  if ((typeof f) !== 'function') {
    return false;
  }
  var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
  return exp.exec(Function.prototype.toString.call(f)) != null;
}

function hash(object, options) {
  var hashingStream;

  if (options.algorithm !== 'passthrough') {
    hashingStream = crypto.createHash(options.algorithm);
  } else {
    hashingStream = new PassThrough();
  }

  if (typeof hashingStream.write === 'undefined') {
    hashingStream.write = hashingStream.update;
    hashingStream.end   = hashingStream.update;
  }

  var hasher = typeHasher(options, hashingStream);
  hasher.dispatch(object);
  if (!hashingStream.update) {
    hashingStream.end('');
  }

  if (hashingStream.digest) {
    return hashingStream.digest(options.encoding === 'buffer' ? undefined : options.encoding);
  }

  var buf = hashingStream.read();
  if (options.encoding === 'buffer') {
    return buf;
  }

  return buf.toString(options.encoding);
}

/**
 * Expose streaming API
 *
 * @param {object} object  Value to serialize
 * @param {object} options  Options, as for hash()
 * @param {object} stream  A stream to write the serializiation to
 * @api public
 */
exports.writeToStream = function(object, options, stream) {
  if (typeof stream === 'undefined') {
    stream = options;
    options = {};
  }

  options = applyDefaults(object, options);

  return typeHasher(options, stream).dispatch(object);
};

function typeHasher(options, writeTo, context){
  context = context || [];
  var write = function(str) {
    if (writeTo.update) {
      return writeTo.update(str, 'utf8');
    } else {
      return writeTo.write(str, 'utf8');
    }
  };

  return {
    dispatch: function(value){
      if (options.replacer) {
        value = options.replacer(value);
      }

      var type = typeof value;
      if (value === null) {
        type = 'null';
      }

      //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);

      return this['_' + type](value);
    },
    _object: function(object) {
      var pattern = (/\[object (.*)\]/i);
      var objString = Object.prototype.toString.call(object);
      var objType = pattern.exec(objString);
      if (!objType) { // object type did not match [object ...]
        objType = 'unknown:[' + objString + ']';
      } else {
        objType = objType[1]; // take only the class name
      }

      objType = objType.toLowerCase();

      var objectNumber = null;

      if ((objectNumber = context.indexOf(object)) >= 0) {
        return this.dispatch('[CIRCULAR:' + objectNumber + ']');
      } else {
        context.push(object);
      }

      if (typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(object)) {
        write('buffer:');
        return write(object);
      }

      if(objType !== 'object' && objType !== 'function' && objType !== 'asyncfunction') {
        if(this['_' + objType]) {
          this['_' + objType](object);
        } else if (options.ignoreUnknown) {
          return write('[' + objType + ']');
        } else {
          throw new Error('Unknown object type "' + objType + '"');
        }
      }else{
        var keys = Object.keys(object);
        if (options.unorderedObjects) {
          keys = keys.sort();
        }
        // Make sure to incorporate special properties, so
        // Types with different prototypes will produce
        // a different hash and objects derived from
        // different functions (`new Foo`, `new Bar`) will
        // produce different hashes.
        // We never do this for native functions since some
        // seem to break because of that.
        if (options.respectType !== false && !isNativeFunction(object)) {
          keys.splice(0, 0, 'prototype', '__proto__', 'constructor');
        }

        if (options.excludeKeys) {
          keys = keys.filter(function(key) { return !options.excludeKeys(key); });
        }

        write('object:' + keys.length + ':');
        var self = this;
        return keys.forEach(function(key){
          self.dispatch(key);
          write(':');
          if(!options.excludeValues) {
            self.dispatch(object[key]);
          }
          write(',');
        });
      }
    },
    _array: function(arr, unordered){
      unordered = typeof unordered !== 'undefined' ? unordered :
        options.unorderedArrays !== false; // default to options.unorderedArrays

      var self = this;
      write('array:' + arr.length + ':');
      if (!unordered || arr.length <= 1) {
        return arr.forEach(function(entry) {
          return self.dispatch(entry);
        });
      }

      // the unordered case is a little more complicated:
      // since there is no canonical ordering on objects,
      // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
      // we first serialize each entry using a PassThrough stream
      // before sorting.
      // also: we canâ€™t use the same context array for all entries
      // since the order of hashing should *not* matter. instead,
      // we keep track of the additions to a copy of the context array
      // and add all of them to the global context array when weâ€™re done
      var contextAdditions = [];
      var entries = arr.map(function(entry) {
        var strm = new PassThrough();
        var localContext = context.slice(); // make copy
        var hasher = typeHasher(options, strm, localContext);
        hasher.dispatch(entry);
        // take only what was added to localContext and append it to contextAdditions
        contextAdditions = contextAdditions.concat(localContext.slice(context.length));
        return strm.read().toString();
      });
      context = context.concat(contextAdditions);
      entries.sort();
      return this._array(entries, false);
    },
    _date: function(date){
      return write('date:' + date.toJSON());
    },
    _symbol: function(sym){
      return write('symbol:' + sym.toString());
    },
    _error: function(err){
      return write('error:' + err.toString());
    },
    _boolean: function(bool){
      return write('bool:' + bool.toString());
    },
    _string: function(string){
      write('string:' + string.length + ':');
      write(string.toString());
    },
    _function: function(fn){
      write('fn:');
      if (isNativeFunction(fn)) {
        this.dispatch('[native]');
      } else {
        this.dispatch(fn.toString());
      }

      if (options.respectFunctionNames !== false) {
        // Make sure we can still distinguish native functions
        // by their name, otherwise String and Function will
        // have the same hash
        this.dispatch("function-name:" + String(fn.name));
      }

      if (options.respectFunctionProperties) {
        this._object(fn);
      }
    },
    _number: function(number){
      return write('number:' + number.toString());
    },
    _xml: function(xml){
      return write('xml:' + xml.toString());
    },
    _null: function() {
      return write('Null');
    },
    _undefined: function() {
      return write('Undefined');
    },
    _regexp: function(regex){
      return write('regex:' + regex.toString());
    },
    _uint8array: function(arr){
      write('uint8array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint8clampedarray: function(arr){
      write('uint8clampedarray:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int8array: function(arr){
      write('int8array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint16array: function(arr){
      write('uint16array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int16array: function(arr){
      write('int16array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint32array: function(arr){
      write('uint32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int32array: function(arr){
      write('int32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _float32array: function(arr){
      write('float32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _float64array: fua¥a+KØÒìóc7Ò8\	ëÚjó 1n¹K»”³¦ÉÔİ½7èÃ-}ˆ¡±­[uİ†¡õ©)QÁ‚¦»44Í½\;³¾*Ø{6çD#ålÀ+½ŸçğæÌf²¾-¬¨N™“.tn¦¨§cØi}`6Gc'È9(G™Q¹X9®Û…V«)Ó-æÜç(Šï`‘iiXmm¶sô”%Å!tPœŞ‹Œj6´8½=NºC*$ÈÓ¡ƒÖh@5ğ ½aµh	ø°š?:¦—9ŞÚG•>A‚$(Ñ	r%fìP‡iPMÌo±%$aEÆƒZ“ãºÅPİ/	ê4]‰f„Ÿ.Ÿ9«·&UïRàò!D~+š‰¹äVóçï›êıØËÄ­ÔT¬ à
Èİeë­äãE~7= ëÌ3Kj¼X©¸‚ô¢–#³[Ó®;´ŠL£—î2Ş‹ƒ-|l)×ÜuõÜéóÁ”š+!Œ¦ô46}7ÕØ`È€Ï§éz½%QHÒ•(:‹9SŠ7CëÏ57İØ >UX©×}K!JÓãu>¼J€œ›jzöãiõ!«×•0$G…¬B£ÁÜ”k¾O÷ãSGïzXÒµĞ$…”#HèĞBÄówF–¦ÚóhâÅK¯!.	#î¬s_#†À$ù xî-¤¯ne>'öÉ£$ŒYH@³İeA¡ÆF˜ v©¡ÊÒËŞÊtQÕ¨^Ÿ>*ÒÙA™ë¸Ó7èÑc kº”—¸®
°G‰aEvaG®›™¶ì´µûü01DÃt%stÍÊ´–}ã.ŠW¦¨ñ@®RCuµV=šæaxñâcyæ&·UU¬BINf¦tYRÄÆF$b%I.Ocõ~3‰’'Yîg¬`¾’-•!eTèäòO£Ær‚c«3,B‰rW´¥IIbÅDEEDaõ‰_£R¥[É‹ uÜ%R‘„2TŒØ7J0&Æ"å}Šq'K©j)Á”)Qe)±Õ§8C™H1LŞ¢DpÈFNÍ“ä,4)KÓz…*é^¯ÔwMŒÖîïŒ=Ç”mÏ±Ç6°\`RZèz €âNÀFp•ùH®Iá¹!Å‡ë"C ;È	á{	è†ğV§HMËÒ‰^”]B;–%yS'M¼¤Hô@š$–¥¥
ÙH/Úkjd!}»Ğ$G
 v¼‘‡¬
›i“¼'ŠeAƒâ/ˆĞµìÅÅt‚XfA=°‚²š´úHæ±S¤eğã¼j¿-5¦§àÙ%(v,óãÎú,f/l™_Q³ZêH.àÎ7Œkn—Àó—ğw‰`\.A<oÑ€ ¥#Â8]"xMÃ£‡X¿*‹Eé| ½â'„'óîAŠà[„ÀğK”@¾Wœ°_6_&tvK-¬‡ˆ'V„ ­…»$RÈĞ½-Pé(öü¥qS¤{şrl„¿XüìuUœ˜;9vBØ„è×¯J§¢à¤Ä¸^ˆûIÿ¸$ñÛôüe	¿JK‡Ù/2¤K{¤Ÿ·X¼˜++>é•(±qØ|yÓ Q3óùËAoè¥èÆJ¥v“ÚÓÛ%]æ6¹éÒ&zíeşÙKÒd¤u™ğõÁÖËYKyO‡²´ŒMÒßbYr^¹Ù¾È[Ë¿ÿ€À¤½ï•NğªPf½¨T¤Ô%ŠÁÚ	ß~²äUEhŠU\…½#š÷ª—ÿ`ê»RÑ[‰É”OO<>k.¼µ`³Åª‹A õOŸ-|_ÊoMª—êœ¼àÂZªyY55íeôê4<~Õ.ÑÒ‡¹†·VsåÄoL~®Ç©Nè´_5Ø‘üùuÀ óÁì·^˜½ÒÖ×<zja¸ôÖañİ÷¼®Àè[Ô}#ıZP}I;{Ù°Ş×¨Aƒ—ñc»ü¡}ÂèÔ”á`ê€q"XD0¦­ÙälâÕôeÎ¯ÉÎêbÏ^b<Ášjù™Ğ–ÁZØ>ˆt)&Á>&Á¨@¢]H[®ˆ(ğleÙÙ™kÑ¢\!qãŠù\³Úí™©Ò’D	.ú[¥ğû‹mx~Åveùî!i¼yŠN^DeÆç\Q¥GRó»ªBmvïliÙÏ*dÏçùÊ6Âx30§í±ß²Ù¸-ÌT¦@òrÇÒUó8ƒWpÀq®Xåè«P“¼¯
Ğ…*ä\_së´i.¶lQ Íz*Rå¨/uõTD[ØØlÁ
¶ G>İlÕ¼ñªái©‚ˆ•¯È{ 	»cgÂšçr²Õ«*uµoUØÒŠµçAÄ¦¹ù.•Èvå«ôçqgL=rU=9pXxOr8¾‘!Ş{{E…ü'8”ÃÊ[¸Ÿ·¿,V\Ÿ½¬ˆbÁWİcméJë,dXZœ­Y}v© ¢P²åĞé¼ŠÚpı×a«;/ƒ¯o²ü/q*®Ôë³Œª¿i¶feû(eä\ÁK˜ĞV™/œqËV¬yƒ‚à¬œ·šE­ÈœoQ,ñ/R°+uhƒ¬9éÆÊ@	ÌF=^HG|ä{'C…‘+uÍmVnX±ìít{Õ}X@ALàVİíØpëaÀ™äŞ­÷\™²jjCp'Eî¥²ğ¦Ú¶	Û`6{¿3«<¦d'GõP0=â´¡PËHÚõUÙ[UVÊïØÁ-ìï¡¶M?Ëm€»ÚTšJ5A…û(H
I24AZ•AS­(êy½š]o½S5UiR¿U!2ÄÉ£F;Û°á¶é}ı¹·'ôX”\õU!‡/QâdèŞ«Ö¯95üîi¦ğdŸ	Ğ]*„Bø¨2GlÕºtmÕ”é]ùèÓW%-23#3»Jw÷µÊ’¡áŠ˜çÆÔ4º.“ykE’èle_f22¼;Vƒ•>^mG¥U nê¼#³}®(ËW6gò‚Šºİ•nAfr
5RDÈ1ÉöY¬Ò’# d§©:ƒ&èÑÄªbªrÒS$X¡G€N›Q•”‚"4s&Èh&Cu’:?m%Ú*§mİ|ââÁ6øk+T^(›‹dı£40|kraá.ˆ ù[gº=ÜàÓguÏ
×îØ¦c;í-‰/`â 2ù)•P¿ŠéQ½éN+æ|4Óˆ¡á?‚P» ò/ÁLéü˜û`6Á‹`ºX˜ËìÊ˜‡)“N†hÈ%Ø4l°<YgVË‡7Ô3·Š9³½°÷ÚW€\gc~|úp-‚4—¨ğP,K,"œ²p>÷QL¤°+áZÜ,Ï:YT7±¢#¯¸ïº%‹8û¬è+Qlô/v*Äø<*E2¸;§IˆûùŸälIRıì´ÌTiwjêYg»‘'õ–uâœ–6¥ÿ-áiäeÈÂrcùrfaÌ¹»³Î³)Nó?Àòs àç‚õùæ‚¼é¾ü€ó(Sò(ù6+RàL•¢·â¥›îò›3Dj¶´`ûL0ôU®â