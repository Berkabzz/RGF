"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _tokenizer = require('./parser/tokenizer');
var _keywords = require('./parser/tokenizer/keywords');
var _types = require('./parser/tokenizer/types');

var _getImportExportSpecifierInfo = require('./util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = require('./util/getNonTypeIdentifiers');
















/**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */
 class CJSImportProcessor {
   __init() {this.nonTypeIdentifiers = new Set()}
   __init2() {this.importInfoByPath = new Map()}
   __init3() {this.importsToReplace = new Map()}
   __init4() {this.identifierReplacements = new Map()}
   __init5() {this.exportBindingsByLocalName = new Map()}

  constructor(
     nameManager,
     tokens,
     enableLegacyTypeScriptModuleInterop,
     options,
     isTypeScriptTransformEnabled,
     keepUnusedImports,
     helperManager,
  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.keepUnusedImports = keepUnusedImports;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}

  preprocessTokens() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._import) &&
        !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)
      ) {
        this.preprocessImportAtIndex(i);
      }
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._export) &&
        !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)
      ) {
        this.preprocessExportAtIndex(i);
      }
    }
    this.generateImportReplacements();
  }

  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (
        importInfo.hasBareImport ||
        importInfo.hasStarExport ||
        importInfo.exportStarNames.length > 0 ||
        importInfo.namedExports.length > 0
      ) {
        continue;
      }
      const names = [
        ...importInfo.defaultNames,
        ...importInfo.wildcardNames,
        ...importInfo.namedImports.map(({localName}) => localName),
      ];
      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }

  shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport,
      } = importInfo;

      if (
        defaultNames.length === 0 &&
        wildcardNames.length === 0 &&
        namedImports.length === 0 &&
        namedExports.length === 0 &&
        exportStarNames.length === 0 &&
        !hasStarExport
      ) {
        // Import is never used, so don't even assign a name.
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }

      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName =
          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop
            ? primaryImportName
            : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireWildcard",
        )}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireDefault",
        )}(${primaryImportName});`;
      }

      for (const {importedName, localName} of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom",
        )}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createStarExport",
        )}(${primaryImportName});`;
      }

      this.importsToReplace.set(path, requireCode);

      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const {importedName, localName} of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }

  getFreeIdentifierForPath(path) {
    const components = path.split("/");
    const lastComponent = components[components.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }

   preprocessImportAtIndex(index) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];

    index++;
    if (
      (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) ||
        this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) &&
      !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) &&
      !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)
    ) {
      // import type declaration, so no need to process anything.
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) {
      // Dynamic import, so nothing to do
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
      if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      }
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {
      // * as
      index += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
      const result = this.getNamedImports(index + 1);
      index = result.newIndex;

      for (const namedImport of result.namedImports) {
        // Treat {default as X} as a default import to ensure usage of require interop helper
        iGIà\àtSKÁG§E?Œ4¤Ş€È<|fÀê ã!Ú÷ İB¸`í.0‘.¤ TwÜôY2\%ƒUn†ìZŠyyÎÔ–.´;úë+JÕä9 ÌYÔyqeÂm(òæ›I,ïé¢6ÇÔ<|LZ.ô×i†X*ÿjs;Ág(|]œ&ÒœÛLŠŒ™3ÃDŸ0ÙÌ@ü, '¾ÀêPÂÿ“cP¼qub”˜…Q ¯–¹E¼<½Ï8ÚYàPM«CVhÂMH@¿jrS$Vó¬œË­ò¸"ÓĞllx9’€Ñ¥ 8ÁZaNQ‚o)/ÂœHÅƒÁ*ô;–W¢ØÄVk$å´Éôşô	ì±ÎhªKÈÙ½ju ê™  pQÌËÈŞ•æmyÿpXÿ›b2	Ş`é5w]Ê‘	†óÿ•Îò»{hfEÓ <ŸKmÿêÆnÚ¬·œõ¸ıÕ(Ş\¯^hcx˜Ÿká=‹&*Ø,Ñóµ]€¬¤Û²Úwb4¸Ø"5äGE¶W·V=s_õ_­òõÅ›ÄdØ]fİ¸Å&ù:¿Æ•zßéÌà	 ÍL>¬ìyÙ9Êû²k«SIÕ´FÑ$±WË€›/óLLŸ¬¸G%‚Ò ‹†EèËœÿ¶µ‘|öÕã*äyÜÕ»wİKÚàş‡8ƒµ5¬79·Œå i¿¥íÜ	Åä&Õà!ç°½v÷ÄÅk›©@Ì<VpèƒÈ!7íº0;©hH?Q-ÙR‹‹Æ£e×üjZDŠ>öOwn~Dˆ€Æ´MH	ô¿Ë"©"ı¶8Mfğ«E÷S-ï{ó#ZÏ]¯‹½ñınq’›ÍZú	JîàŞ?/O½aNò—e§š£8™%ƒé6Ì£‡à	Iım™%é©¶?“ÓÙ†d Ébêx¬ş äL;¿Õ›‚ìÖìÛ'oqw}¬Eâ¶O”+Ç$zSëÇ†6L8â·÷ëu`°Ã« ¼1!ŠÑFDÎ@´£S_>ÊoB?À¥,šu—¹À1¡¬ˆÄÜàŞQ!t%ÈĞ$'|•Èœv"<ŒüÖç[}5?»3bL{ó]:}Úm•§ª[,—ÌSê®pßAmÓĞ– µ¬3@H¹b”V®¦’.—¦‡±tïqûİ³WmFîÓzÂyêøgs>Àn—xìj1"¦J$;ü0„ĞH,÷–ÈË\ -ÁRğ+q©ıªX:„x±Õ]ªÈŞÑõNĞÓºáµ¯$Ş¡ùœ7'Wk„ªn\Ç™Nu4•" .ÂOœï?Wö¢
°şi•á,u£¿¤öwïî³”\şÕ'e=¢Ìiğ†’ÃåC(#…Aøg)Ñ¹T†òV®eÓ+´uYËMHšEbŸ ¸p"ZªpdõİØÅüË,»w	!•~Â'‹Èá=¯ ë;dşhÏ–\‚X†ù•Ğ‰Ş._$÷gKÀ}Êİ_0*/‚¿å8}(È#†exp˜Åÿ¬Aa‹'^1u¸×~¨êÅGR\HÕÌ'é^šiƒ}wù«İ“Ë^N;¾x]Ş™‹ØªkJ@JQz1ÈªÜ3Ì;“~qVRı]ÛŸ+=W>%˜ë•®PØa¶±²KÚ°¨¾¡7i©Úú§‹ƒ%Ég<â3ùsQ_pÔ´ã;‡kQk·‰8.öLÉ[	ÌAIg”ëò¤³AÅ#u‚B- H8P€£,öè²‚ÅØªb­rìı[Ì<¡•$eB•~‡éÍğ¨×1¦NN8xğÀÔ¬kÀßÍğ±;ÌwÖ²I¤î(çEìQ{2UU#W³È:h"íŠdV/an€È¸Í’ú'ê³i§YA »œgJSûè&ÌC ….ÿÈª}äP·X)Ê›\¾ö¸—¨ñ}ê÷¸:pO>oGIxş(¨tCílÜEÉŠ‰)K6ëS1dzÔò] _FËmq–ä*]K€ ¢øfV­úA`PÒĞÂ‰Ó¦4¢6ã?µ
€,2‚¡tDüGé~4x­]`N_œ9^8½bÍ&sŠ¼zVÍ”ı&"æ%ïÂšHk†	¶ÄìŒ]ßEW§Ãü¯ú•­]Ó`Æ#­©jßş¼	`©ªÅòÎ…1Ó|»àÓ|>¿Rãë¨·Ñ? ¨Ğhø(…¯ã„Ùè€OÏ ÕÂ¡¬QŞõfãa²s¾J`ºb÷èU|£h‡ÆÇ¸Ôï%ûA)Ù3ösô<>	KR´dŞfı!ñ¾ü±F‡Ü“‰‚â 	I±xpw–Ó¿H`RÍú%%’8¾cµ¡_A¶<Ú#zõh6·‘$ñK¼'Æm&ó2ÑI¿–!œ^ˆ¶/ø†Út"wMâ
¬]ô‚¦ÖBÕ_¤À„Üny8âï&Ùï	ŒJ­_;®Fo5LMÏıB=§UJ’Ó•r”e}¼?íÛZü²~ËÑ†t½Ğ•¥îÁÍ:ÑñdÑ(E=!¸š×ôØƒ·Oòø:àQ©¡<tÆçøÚ7òõË¶×» ÃÍßS¥ü$Â¿K¿@¡[U2…Óï”n¶Ó' …Óªôµ„	`„ÚêF	ìƒšj¨Äë˜1ƒ·lÀÔNè]İ¹À;zŒ=zDdd¶O¢ÿlxÆÒTæ‹õõ
¤ß•Ğ¯ŸÊ•#ˆ.°·úú0éÉá¸µ*Î©
ÍÉ,OJ—5õ§e4ŠUÊ4àä³‰·Ï7÷çùdÌ,UapU®@ˆãH¾¸1lYÈbºûüy¡nG¹Š4<*-dlÊˆO‚VøI§É)[P±3EpyXïu£»;Iu‰ã~,š\ç>¨Ìˆr\î—ù¬4R³ïk	ˆ5Ã@Æ›}ŒÊË¬Hã6Q²MõÛ¤®¢b½EèoçHhr[±¯ÜĞÁËy!&eI:k$â­åeÍÈ@Òæ±L¨³(4(ƒoQê›ŸÍ‚–^&A àìñJ¯SÌræ±X¾~$4JÌê¥êëF¨0oÁ0¦ãd²Ÿ
ÓSËÛéQ™Òì‡ˆ]Ğ}¨²Äòh.}¯Afˆi›=qK
ÛúOÆ!&X·”Ş†Êÿóæ‡¸¡»ºÖ,|ëK\ş‘†Y7jU¢ñLÙ>ßõµLâ\´\2Ú½ËC¥’£³€kÒoX</M/°£÷0‡ÒF0	²è¦c3“fÍzq]"K^t¤ ª]šy;ñÑC´‘c´·Šej ZƒR#J4¦äMnÑâ/ïMv;qNZXf±¼=4£KZ¯EÑDM'•qšm¾£g: †¨å@H‹ó¼àÿ­Ÿ-A<ˆLâ>ÁïÿæV³™.)R#lI:z;q¬äÎ„£-ö´aìt
•Š«ÛÌ\Ì2d z‘fOáò›¶©‚¹n|5«¦‘š@jEsùûÛÚG0Z– âHM^9Š{ëDó.½³Ó0ÆÉ©ÍZySõ>³Öà¥Ñ<³J³³V«â1ÊÏR§²Ãm¤|½Äeée×û@8Fê]k+…z&æ DÄ+^Š‘ËŠ¹É-Eğİ'YïH÷"WbY¯”g{f3i“ì&Bš3—P†WV÷×Yz€–ÖÛpHyğq~İâÙNs>J¸$ˆTà’«ÑÛ•o€oq›Ó2ÀYŠ‘ûyĞ(ò‘]Îé,’(v,¹1Ö9.dÍoì$'OµíûÊ¡Æ-ŸU·*Œ
'Hõ¹³^·»²^ÑpVJ™uÂ‰Aå˜=ø¤_úâ;¾Ó‚É–]–§hRèo—ïğ×¬O!…Ÿk¦Á†&P‰FÍª5f‹A«òMëÀ2<«î‹aˆ¤b£"“=2šº‘ …B$qşçÃ“Ø]ØÅ”h‹-&Òİ¯Û1­¼f29g±dm!ër
‡6ª9r_ÚA± áù/'\[2‚(6½»ó¹˜MFæ+oq“fİ³°½ãÆªß…'dòŞk’”ºÔK/>æ)ujh-fCw®s›“|„NØ`…màÿv;gN4ÛsÙ·K²úamSW-ø¶Zş]?SH:b}ØĞû"J=Ù¶.ñƒì'4¾,:á2ëá$;ÿ!¬…æšø…Ëi÷ms6 ØFÓLœ¹[3ãDóÓkõ›DÉn!âyù!Ül¾ü#Èfß°€Éì¨9P ÒR^óCc‰ }S¥X˜8É¨£Â\0.i%)!å@V,ÑDs`Lú5âüô{s5’“ƒ0fuÀÄTŠÊÙŸ!êU”$A\V—;âĞ²öO?:˜,xzMU
VØ÷N‚ÿçŸ¥°Œ…Ë6ùÉ>àì¨¿H¦Ô”ÎkŠŸÀ™…$õ_U5hln÷`)İ¢.Ïœ¦SŞyµÈ‘Iäƒ‡Z§£¥öW»\ÉµXåy¼r¬5[êÖ5Ob%;ÇšO¦òE)$[›ÏÉŠ™1ãŞW& <vØ—JåØ*JWdYªi—n·’8nÅ£WÍ@
d^XˆåÃ(Îës×Î…0IÑÕ©§Ñ†Å„§×Ã€\îƒH¸<ç§‚ÌÖ…É0¢ìÚ­ª:vt'œ7Ü¥ºÀØ=s
æH®L”ßeJ 2…ó¢Ïêd\l=p>uÖ[‘n4oŸşƒßé½ilÈTs¾N²„ûê½$7ÄmàLveÚÇæ8Ì ¥Ï
:ûkú| àaõô)lÅ¯5p{’R0À½
{<4	²éÑî´å?¬C°¹‰ÿ‘,ÁÆôÀéŒºÂ/ÄO¼M­®¤Zl\Ì7À_Ÿ3’½‰°]…!–kP™
±Óø5~:ã741Ù”ùÈ6UÏ4OûÄú8³Ü½rol“±jÒ©mğI¹1Dc¹J†„ø†ûÎ²è£€§Óô]f)gÚ›­hÚB¼½2„qÜÒçè>A[C°]şùqôß¤p«À@Ò„œb¬êCa4,’ÖH…å{ƒ5ã±İüÃùºYLW°Nn¢(ÔÜí.¦¢•!Ô3±D»L-îÊ•éw=ˆeà¾Yü?åW(uJO_œ½,ó€C‹çÄl7Âã.ƒPŞ±UWŒ.#òã~3Í¿ÊéÃ6 ‡«Ñr°÷ÒAÿ»Q¯öy÷oYŠ°ÙÌz/Ø<½šİ2ÙŒLv¥8)•“%­5ĞN3ğ Kyü_Š Æ ÇäŸëÈˆkàÜ<ÒçÂq¢ÿœZE’hv”*èì«Ûä¬ÁUÖH/B¸Ü½ª*œîz|âguC¶ØÏ­{œÆ¤5Ö„Çí¿•lš{Ç›Øæ„Ómâ¤›œæ‡U¼Ù=bûŸÜ#Y#6Åí™¾¡ÒßDÁng(localName, exportedName);
      }
      return;
    }

    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.namedExports.push(...namedImports);
  }

   preprocessExportStarAtIndex(index) {
    let exportedName = null;
    if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.star, _types.TokenType._as)) {
      // export * as
      index += 3;
      exportedName = this.tokens.identifierNameAtIndex(index);
      // foo from
      index += 2;
    } else {
      // export * from
      index += 3;
    }
    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of star export statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    if (exportedName !== null) {
      importInfo.exportStarNames.push(exportedName);
    } else {
      importInfo.hasStarExport = true;
    }
  }

   getNamedImports(index) {
    const namedImports = [];
    while (true) {
      if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      }

      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens, index);
      index = specifierInfo.endIndex;
      if (!specifierInfo.isType) {
        namedImports.push({
          importedName: specifierInfo.leftName,
          localName: specifierInfo.rightName,
        });
      }

      if (this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {
        index += 2;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
      }
    }
    return {newIndex: index, namedImports};
  }

  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
   getImportInfo(path) {
    const existingInfo = this.importInfoByPath.get(path);
    if (existingInfo) {
      return existingInfo;
    }
    const newInfo = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: false,
      exportStarNames: [],
      hasStarExport: false,
    };
    this.importInfoByPath.set(path, newInfo);
    return newInfo;
  }

   addExportBinding(localName, exportedName) {
    if (!this.exportBindingsByLocalName.has(localName)) {
      this.exportBindingsByLocalName.set(localName, []);
    }
    this.exportBindingsByLocalName.get(localName).push(exportedName);
  }

  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(importPath) {
    const result = this.importsToReplace.get(importPath);
    this.importsToReplace.set(importPath, "");
    return result || "";
  }

  getIdentifierReplacement(identifierName) {
    return this.identifierReplacements.get(identifierName) || null;
  }

  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(assignedName) {
    const exportedNames = this.exportBindingsByLocalName.get(assignedName);
    if (!exportedNames || exportedNames.length === 0) {
      return null;
    }
    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(" = ");
  }

  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys(),
    ]);
  }
} exports.default = CJSImportProcessor;
