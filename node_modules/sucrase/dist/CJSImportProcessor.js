"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _tokenizer = require('./parser/tokenizer');
var _keywords = require('./parser/tokenizer/keywords');
var _types = require('./parser/tokenizer/types');

var _getImportExportSpecifierInfo = require('./util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = require('./util/getNonTypeIdentifiers');
















/**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */
 class CJSImportProcessor {
   __init() {this.nonTypeIdentifiers = new Set()}
   __init2() {this.importInfoByPath = new Map()}
   __init3() {this.importsToReplace = new Map()}
   __init4() {this.identifierReplacements = new Map()}
   __init5() {this.exportBindingsByLocalName = new Map()}

  constructor(
     nameManager,
     tokens,
     enableLegacyTypeScriptModuleInterop,
     options,
     isTypeScriptTransformEnabled,
     keepUnusedImports,
     helperManager,
  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.keepUnusedImports = keepUnusedImports;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}

  preprocessTokens() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._import) &&
        !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)
      ) {
        this.preprocessImportAtIndex(i);
      }
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._export) &&
        !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)
      ) {
        this.preprocessExportAtIndex(i);
      }
    }
    this.generateImportReplacements();
  }

  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (
        importInfo.hasBareImport ||
        importInfo.hasStarExport ||
        importInfo.exportStarNames.length > 0 ||
        importInfo.namedExports.length > 0
      ) {
        continue;
      }
      const names = [
        ...importInfo.defaultNames,
        ...importInfo.wildcardNames,
        ...importInfo.namedImports.map(({localName}) => localName),
      ];
      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }

  shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport,
      } = importInfo;

      if (
        defaultNames.length === 0 &&
        wildcardNames.length === 0 &&
        namedImports.length === 0 &&
        namedExports.length === 0 &&
        exportStarNames.length === 0 &&
        !hasStarExport
      ) {
        // Import is never used, so don't even assign a name.
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }

      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName =
          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop
            ? primaryImportName
            : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireWildcard",
        )}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireDefault",
        )}(${primaryImportName});`;
      }

      for (const {importedName, localName} of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom",
        )}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createStarExport",
        )}(${primaryImportName});`;
      }

      this.importsToReplace.set(path, requireCode);

      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const {importedName, localName} of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }

  getFreeIdentifierForPath(path) {
    const components = path.split("/");
    const lastComponent = components[components.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }

   preprocessImportAtIndex(index) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];

    index++;
    if (
      (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) ||
        this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) &&
      !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) &&
      !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)
    ) {
      // import type declaration, so no need to process anything.
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) {
      // Dynamic import, so nothing to do
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
      if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      }
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {
      // * as
      index += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
      const result = this.getNamedImports(index + 1);
      index = result.newIndex;

      for (const namedImport of result.namedImports) {
        // Treat {default as X} as a default import to ensure usage of require interop helper
        iGI‡\‡tSK¡GßE?å4Åû§ﬁÄ»<|f¿èÍ „!⁄˜ ›B∏`Ì.0ë.§ Tw‹ÙY2\%ÉUûnÜÏZäyyŒ‘ñ.¥;˙Î+J’‰9 ÃY‘yqe¬m(ÚÊõI,ÔÈ¢ù6«‘<|LZ.ûÙ◊iÜX*çˇjs;¡g(|]ú&“ú€Läåô3√Dü0ŸÃ@é¸, 'æ¿ÍP¬ˇìcPºqubîòÖQ ØñπEº<Ωœç8⁄Y‡PM´CVh¬MH@øjrS$VÛ¨úÀ≠Ú∏"”–llx9íÄ—•†8¡ZaNQÇo)/¬úH≈É¡*Ù;ñW¢ÿƒVk$Â¥…éÙ˛Ù	Ï±Œh™Kù»ŸΩju†Íô  pQÃÀ»ﬁïÊmyˇpXéˇõb2	ﬁ`È5w] ë	ÜÛˇïŒÚª{hfE” <ûüKmˇÍ∆n⁄¨∑úı∏˝’(ﬁé\Ø^hcxòük·=ã&*ÿêç,—Ûµ]Ä¨§€≤⁄wb4û∏ÿ"5‰GE∂W∑V=s_ı_≠Úı≈õƒdÿ]f›∏≈&˘:ø∆ûïzﬂÈÃ‡	 ÕL>¨ÏyŸ9 ˚≤k´SI’¥F—$±WÀÄõ/ÛLLü¨∏G%Ç“†ãÜEËÀúˇ∂µë|ˆ’„*‰y‹’ªw›K⁄‡˛á8Éµ5¨79∑åÂ iø•Ì‹	ê≈‰ù&’‡!Á∞ûΩv˜ƒ≈kõ©@Ã<VpËÉ»!7Ì∫0;©hH?Q-ŸRãã∆£e◊¸jZDä>ˆOwn~DàÄ∆¥MH	ÙøÀ"©"çÅ˝∂8Mf´E˜S-Ô{Û#Zœ]ØãΩÒ˝nqíõÕZ˙	JÓ‡ﬁ?é/OΩûaNÚóeßö£8ô%ÉÈ6Ã£á‡	I˝mèô%È©∂?ì”ŸÜd …bÍx¨˛ ‰L;ø’õÇÏ÷Ï€'oêqw}¨ÅE‚∂Oî+«$zSÎ«Ü6L8‚∑˜Îu`∞√´ º1!ä—FDŒ@¥£S_> oB?¿•,öuóπé¿1°¨àƒ‹‡êﬁQ!t%»–$'|ï»úv"<å¸÷Á[}5?ª3bL{Û]:}⁄mïß™[,óÃSçÍÆpﬂAm”–ñ†µ¨3@HπbîVÆ¶í.ó¶á±tÔq˚›≥WmFÓ”z¬yçÍ¯gs>¿nóxÏj1"¶J$;¸0Ñ–H,˜ñ»À\ û-¡Rù+q©˝™X:Ñx±’è]™»ﬁ—ıN–”∫·µØ$ﬁ°˘ú7'WkÑ™n\«ôNu4ï" .¬OúÔ?Wˆ¢
∞˛iï·,u£ø§ˆwÔÓ≥î\˛’'e=¢ÃiÜí√ÂC(#ÖA¯g)—πTÜÚVÆe”ç+¥uYÀMHöEbü ∏p"Z™pdıù›ÿ≈¸À,ªw	!ï~¬'ã»·=Ø Î;d˛hœñ\ÇXÜ˘ï–âﬁ._$˜gK¿} ›_0*/ÇøÂ8}(»#Üexêpò≈ˇ¨Aaã'^1u∏◊~®Í≈GR\H’Ã'È^öiÉ}w˘´›ìÀ^N;æx]ﬁôãÿ™kJ@êJQz1»™‹3Ã;ì~qVûR˝]€ü+=W>%òÎïÆPÿa∂±≤K⁄∞®æ°7i©⁄˙ßãÉ%…g<‚3˘ésQ_p‘¥„;ákQk∑â8.ˆL…[	ÃAIgîÎÚ§≥A≈#uÇB- H8PÄ£,ˆË≤Ç≈ÿ™b≠rÏ˝[Ã<°ï$eBï~áÈÕ®◊1¶NN8x¿‘¨çk¿ﬂÕ±;Ãw÷≤I§Ó(ÁEÏQ{2UUù#W≥»:h"ÌädV/anÄ»∏Õí˙'Í≥ißYA ªúgJS˚Ë&ÃC Ö.ˇ»™}‰P∑X) êõ\æˆ∏óê®Ò}éÍ˜∏:pO>oêGIx˛(®tCÌl‹E…äâ)K6ÎSç1dz‘Ú] _FÀmqñ‰*]KÄ ¢¯fV≠˙A`P“Å–¬â”¶4¢6„?µ
Ä,2Ç°tD¸GÈ~4x≠]`N_ú9^8ΩbÕ&säºzVÕûî˝&"Ê%Ô¬öHkÜ	∂ƒÏå]ﬂEWß√¸Ø˙ï≠]”`∆#≠©jﬂ˛º	`©™≈ÚŒÖ1”|ª‡”|>øèR„Î®∑—? ®–h¯(ÖØ„ÑçŸËÄOœ ’ê¬°¨Qﬁıfé„a≤sæJ`∫b˜ËU|£há∆«∏‘ÔéçÅ%˚A)Ÿé3ˆsÙ<>	KR¥dﬁf˝!Òæ¸±Fá‹ìâÇ‚ 	I±xpwñ”øçH`RÕ˙%%í8æcµ°_Aè∂<⁄#zıh6∑ë$ÒKº'∆m&Û2—Iøñ!ú^à∂/¯Ü⁄t"wM‚
¨]ÙÇ¶÷B’_§¿Ñ‹nyù8‚Ô&ŸÔ	åJ≠_;ÆFo5LMœ˝B=ßUJí”ïrîe}º?Ì€Z¸≤~À—ÜtΩ–ï•Ó¡Õ:—Òd—(E=!∏ö◊ÙÿÉ∑ûOÚ¯:‡Q©°ê<t∆Á¯⁄7ÚıÀ∂◊ª†√ÕﬂS•¸$¬øKø@°[U2Ö”Ôîn∂”' Ö”™ÙµÑ	`Ñ⁄ÍF	ÏÉöj®ƒÎò1É∑l¿‘NË]›π¿;zå=zDdd∂êO¢ˇlçx∆“TÊãıı
§ﬂï–Øü ï#à.∞∑˙˙0È…·∏µ*Œ©
Õ…,OJó5ıße4äU 4Å‡‰≥â∑œ7˜Á˘dÃ,UapUÆùù@à„Hæ∏1lY»b∫˚¸y°nGπä4<*-dl àOÇV¯Iß…)[P±3EpyXÔu£ª;Iuâ„~,ö\ùÁ>®Ãàr\Óó˘¨4R≥Ôk	à5√@∆õ}å À¨H„6Q≤Mı€§Æê¢bΩEËoÁHhr[±Ø‹–¡Ày!&eI:k$‚≠ÂeÕ»@“Ê±L®≥(4(ÉoQÍõüÕÇñ^&A†‡ÏÒJØSÃrÊ±Xæ~$4JÃÍ•ÍÎF®0o¡0¶„d≤ü
”SÀ€ÈQô“Ïáà]–}®≤ƒÚh.}ØAfàiõ=qK
€˙O∆!&X∑îﬁÜ ˇÛÊÅá∏°ª∫÷,|ÎK\˛ëÜY7jU¢ÒLŸ>ﬂıµL‚\¥\2⁄ΩÀC•í£≥Äk“oX</M/∞£˜0á“F0	≤Ë¶c3ìfÕzq]"K^t§ ™]öy;Ò—C¥ëc¥∑äej ZÉR#J4¶‰Mn—‚/ÔMv;qNZXf±º=4£KZØE—DM'ïqöémçæ£g:†Ü®Â@HãÛº‡ˇ≠ü-A<àL‚>¡ÔˇÊV≥ô.)R#lI:z;q¨‰ŒÑ£-ˆ¥ÅaÏût
ïä´€Ã\Ã2d zëfùO·Úõ∂©Çπn|5´¶ëö@jEs˘˚€⁄G0Zñ†‚HM^9äù{ÎDÛ.Ω≥”0∆…©ÕZySı>≥÷‡•—<≥J≥û≥V´‚1 œRß≤√m§|ΩƒeÈe◊˚@8FÍ]k+Öz&Ê Dƒ+^äëÀäπé…-E›'YÔH˜"WbYØîg{f3iìÏ&Bö3óPÜWÅV˜◊YzÄñ÷€pHyq~›‚ŸNs>J∏$àT‡í´—€ïoÄoqõ”2¿Yäë˚y–(Úë]ŒÈ,í(v,π1÷9.dÕoÏ$'OµÌ˚ °∆-üU∑*èå
'Hıπ≥^∑ªû≤^—pVJôu¬âAÂò=¯§_˙‚;æ”Ç…ñ]ñßhRËoóÔ◊¨O!Öük¶¡Ü&éPâFÕ™5fãA´ÚMÎ¿2<´ûÓãaà§b£"ì=2ö∫ë ùÖB$q˛Á√ìÿ]ÿ≈îhã-è&“›Ø€1≠ºf29g±dm!Îr
áç6™9r_ç⁄A± ·˘/'\[2Ç(6ΩªÛπòMFÊ+oqìf›≥∞Ω„∆™ﬂÖ'dÚﬁkíî∫‘K/>Ê)ujh-fCwÆsõì|ÑNÿ`Öm‡ˇv;gN4€sŸ∑K≤˙aèmSW-¯∂Z˛]?SH:b}ÿ–˚"J=Ÿ∂.ÒÉÏ'4æ,:·2Î·$;ˇ!¨ÖÊö¯ÖÀi˜ms6†ÿF”Lúπ[3„DÛ”kıõD…n!‚y˘!‹læç¸#é»fﬂ∞Ä…Ï®9P†“R^ÛCcâ }S•Xò8…®£¬\0.i%)!Â@V,—Ds`L˙5‚¸Ù{s5íìÉ0fu¿ƒTä Ÿü!ÍUî$A\Vó;‚–ê≤ˆO?:ò,xzMU
Vÿ˜NÇéˇÁü•∞åÖÀ6˘…>‡Ï®øHÅ¶‘îŒkÅäü¿ôÅÖ$ı_U5hlên˜`)›¢.œú¶Sﬁyµ»ëI‰ÉáZß£•ˆWª\…µXÂyºr¨5[Í÷5Ob%;«öçO¶ÚûE)$[õœ…äô1„ﬁW& <vÿêóJÂÿ*JWdY™ióùn∑í8n≈£WÕ@
d^XàÂ√(ŒÎs◊ŒÖ0I—’©ß—Ü≈ÑßÅ◊√Ä\ÓÉH∏<ÁßÇÃ÷éÖ…0¢Ï⁄≠™:vùt'ú7‹•∫¿Åÿ=s
ÊHÆLîﬂeJ 2ÖÛ¢œÍd\l=p>u÷[ën4oü˛ÉﬂÈΩil»TsæN≤Ñ˚ÍΩ$7ƒm‡Lve⁄«Ê8Ã •œ
:˚k˙|†‡aıùÙ)l≈Ø5p{íR0¿Ω
{<4	≤È—Ó¥Â?¨C∞πâˇë,¡∆Ù¿Èå∫¬/ƒOºM≠Æ§Zl\ÅÃ7¿_ü3íΩâ∞]Ö!ñkPô
±”¯5~:„741Ÿî˘»6Uœ4O˚ƒ˙8≥‹Ωrolì±j“©mIπ1DcπJéÜÑ¯Ü˚Œ≤Ë£Äß”Ù]f)g⁄õ≠h⁄BºΩ2Ñq‹“ÁË>A[C∞]˛˘qÙﬂ§p´¿@“ÑÅúb¨ÍCa4,í÷HÖÂ{É5„±›¸√˘∫ûYLW∞Nn¢(‘‹Ì.¶¢ï!‘3±DªL-Ó ïÈw=àe‡æY¸?ÂW(uJO_úΩ,ÛÄCãÁƒl7¬„.ÉPﬁ±UWå.#Ú„~3Õø È√6 á´—r∞˜“AˇªQØˆy˜oYä∞ŸÃz/ÿ<Ωö›2ŸåLv•8)ïì%≠5–N3 Ky¸_èä ∆ «‰üÎ»àk‡‹<“Á¬q¢ˇúZEíhvî*ËÏ´€‰¨¡U÷H/B∏‹Ω™*úÓz|‚guC∂ÿœ≠{ú∆§5÷Ñ«Ìøïlö{«õÿÊÑ”m‚§õúÊáUºŸ=b˚ü‹#Y#6≈Ìôæ°“ﬂD¡ng(localName, exportedName);
      }
      return;
    }

    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.namedExports.push(...namedImports);
  }

   preprocessExportStarAtIndex(index) {
    let exportedName = null;
    if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.star, _types.TokenType._as)) {
      // export * as
      index += 3;
      exportedName = this.tokens.identifierNameAtIndex(index);
      // foo from
      index += 2;
    } else {
      // export * from
      index += 3;
    }
    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of star export statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    if (exportedName !== null) {
      importInfo.exportStarNames.push(exportedName);
    } else {
      importInfo.hasStarExport = true;
    }
  }

   getNamedImports(index) {
    const namedImports = [];
    while (true) {
      if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      }

      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens, index);
      index = specifierInfo.endIndex;
      if (!specifierInfo.isType) {
        namedImports.push({
          importedName: specifierInfo.leftName,
          localName: specifierInfo.rightName,
        });
      }

      if (this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {
        index += 2;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
      }
    }
    return {newIndex: index, namedImports};
  }

  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
   getImportInfo(path) {
    const existingInfo = this.importInfoByPath.get(path);
    if (existingInfo) {
      return existingInfo;
    }
    const newInfo = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: false,
      exportStarNames: [],
      hasStarExport: false,
    };
    this.importInfoByPath.set(path, newInfo);
    return newInfo;
  }

   addExportBinding(localName, exportedName) {
    if (!this.exportBindingsByLocalName.has(localName)) {
      this.exportBindingsByLocalName.set(localName, []);
    }
    this.exportBindingsByLocalName.get(localName).push(exportedName);
  }

  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(importPath) {
    const result = this.importsToReplace.get(importPath);
    this.importsToReplace.set(importPath, "");
    return result || "";
  }

  getIdentifierReplacement(identifierName) {
    return this.identifierReplacements.get(identifierName) || null;
  }

  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(assignedName) {
    const exportedNames = this.exportBindingsByLocalName.get(assignedName);
    if (!exportedNames || exportedNames.length === 0) {
      return null;
    }
    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(" = ");
  }

  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys(),
    ]);
  }
} exports.default = CJSImportProcessor;
