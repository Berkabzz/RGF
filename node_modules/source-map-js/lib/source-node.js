/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk@Z  ¹ ?ReleaseTexImage@egl@@YAIPEAX0H@Z Ð ?SurfaceAttrib@egl@@YAIPEAX0HH@Z  Ó ?SwapInterval@egl@@YAIPEAXH@Z  ?BindAPI@egl@@YAII@Z  ª ?QueryAPI@egl@@YAIXZ   ?CreatePbufferFromClientBuffer@egl@@YAPEAXPEAXI00PEBH@Z º ?ReleaseThread@egl@@YAIXZ á ?WaitClient@egl@@YAIXZ  K ?GetCurrentContext@egl@@YAPEAXXZ  $ ?CreateSync@egl@@YAPEAXPEAXIPEB_J@Z 2 ?DestroySync@egl@@YAIPEAX0@Z   ?ClientWaitSync@egl@@YAHPEAX0H_K@Z  x ?GetSyncAttrib@egl@@YAIPEAX0HPEA_J@Z   ?CreateImage@egl@@YAPEAXPEAX0I0PEB_J@Z  . ?DestroyImage@egl@@YAIPEAX0@Z ` ?GetPlatformDisplay@egl@@YAPEAXIPEAXPEB_J@Z ! ?CreatePlatformWindowSurface@egl@@YAPEAXPEAX00PEB_J@Z   ?CreatePlatformPixmapSurface@egl@@YAPEAXPEAX00PEB_J@Z ä ?WaitSync@egl@@YAIPEAX0H@Z  ´ ?QuerySurfacePointerANGLE@egl@@YAIPEAX0HPEAPEAX@Z ¡ ?PostSubBufferNV@egl@@YAIPEAX0HHHH@Z  a ?GetPlatformDisplayEXT@egl@@YAPEAXIPEAXPEBH@Z ¯ ?QueryDisplayAttribEXT@egl@@YAIPEAXHPEA_J@Z ­ ?QueryDeviceAttribEXT@egl@@YAIPEAXHPEA_J@Z  ® ?QueryDeviceStringEXT@egl@@YAPEBDPEAXH@Z   ?CreateImageKHR@egl@@YAPEAXPEAX0I0PEBH@Z  / ?DestroyImageKHR@egl@@YAIPEAX0@Z   ?CreateDeviceANGLE@egl@@YAPEAXHPEAXPEB_J@Z  ¸ ?ReleaseDeviceANGLE@egl@@YAIPEAX@Z  " ?CreateStreamKHR@egl@@YAPEAXPEAXPEBH@Z  0 ?DestroyStreamKHR@egl@@YAIPEAX0@Z Ê ?StreamAttribKHR@egl@@YAIPEAX0IH@Z  ° ?QueryStreamKHR@egl@@YAIPEAX0IPEAH@Z  ± ?QueryStreamu64KHR@egl@@YAIPEAX0IPEA_K@Z  Í ?StreamConsumerGLTextureExternalKHR@egl@@YAIPEAX0@Z Ë ?StreamConsumerAcquireKHR@egl@@YAIPEAX0@Z Î ?StreamConsumerReleaseKHR@egl@@YAIPEAX0@Z Ì ?StreamConsumerGLTextureExternalAttribsNV@egl@@YAIPEAX0PEB_J@Z  # ?CreateStreamProducerD3DTextureNV12ANGLE@egl@@YAIPEAX0PEB_J@Z Ï ?StreamPostD3DTextureNV12ANGLE@egl@@YAIPEAX00PEB_J@Z  y ?GetSyncValuesCHROMIUM@egl@@YAIPEAX0PEA_K11@Z Ò ?SwapBuffersWithDamageEXT@egl@@YAIPEAX0PEAHH@Z  £ ?ProgramCacheGetAttribANGLE@egl@@YAHPEAXI@Z ¥ ?ProgramCacheQueryANGLE@egl@@YAXPEAXH0PEAH01@Z  ¤ ?ProgramCachePopulateANGLE@egl@@YAXPEAXPEBXH1H@Z  ¦ ?ProgramCacheResizeANGLE@egl@@YAHPEAXHI@Z libGLESv2.dll pQueryPerformanceCounter 3GetCurrentProcessId 7GetCurrentThreadId  
GetSystemTimeAsFileTime 4DisableThreadLibraryCalls InitializeSListHead õRtlCaptureContext ýRtlLookupFunctionEntry  RtlVirtualUnwind   IsDebuggerPresent æUnhandledExceptionFilter  ¤SetUnhandledExceptionFilter ¨IsProcessorFeaturePresent KERNEL32.dll   __C_specific_handler  % __std_type_info_destroy_list  > memset  VCRUNTIME140.dll  6 _initterm 7 _initterm_e ? _seh_filter_dll  _configure_narrow_argv  3 _initialize_narrow_environment  4 _initialize_onexit_table  " _execute_onexit_table  _cexit  api-ms-win-crt-runtime-l1-1-0.dll < memcpy                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ÿÿÿÿ    Í] ÒfÔÿÿ2¢ß-+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     h  ¸  89  ¸  Î   8  Ð  T  ä8  T    @9    Å  p9  È  t  9  t    89  Ä  ß  89  à    89    P  89  P  e  89  h    89    ¥  89  ¨    ¼9    8  89  8  L  89  L    ´9    #  ´9  $  ¼  9  ¼  à  ´9  à  	  ´9    g  Ð9  h  ¤  à9  ¤  à  à9  ä    ì9      "    :  @   F   :  F   ]   Ü8  ]   v   Ü8  v      Ü8     À   h9  À   Ø   ¬9                                                                                                                                                          8                    P                    h                 	                    	        $          È  }          $4   V S _ V E R S I O N _ I N F O     ½ïþ             ?                            S t r i n g F i l e I n f o   ^   0 4 0 9 0 4 b 0        C o m p a n y N a m e     (    F i l e D e s c r i p t i o n     2 	  F i l e V e r s i o n     5 . 1 5 . 3 . 0     $    L e g a l C o p y r i g h t   >   O r i g i n a l F i l e n a m e   l i b E G L . d l l     .   P r o d u c t N a m e     l i b E G L     6 	  P r o d u c t V e r s i o n   5 . 1 5 . 3 . 0     D    V a r F i l e I n f o     $    T r a n s l a t i o n     	°    <?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level='asInvoker' uiAccess='false' />
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
                                                                                                                                                                                                                                                                                                                                                                                                                                           